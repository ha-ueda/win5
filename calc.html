<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>WIN5 買い目計算</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: "メイリオ", Meiryo, Hiragino Sans, Hiragino Kaku Gothic ProN, 'ヒラギノ角ゴ ProN W3', 'ヒラギノ角ゴ Pro W3', Helvetica Neue, Helvetica, sans-serif;
            margin: 10px;
            color: #222;
            font-weight: 400;
            user-select: none !important;
            -webkit-user-select: none !important;
            -ms-user-select: none !important;
        }

        * {
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
            box-sizing: border-box;
        }

        .top-bar-right {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        #win5TabSelect {
            padding: 8px 10px;
            font-size: 16px;
            border: 1px solid #cfcfcf;
            border-radius: 6px;
            background-color: #fff;
            color: #222;
            min-width: 160px;
        }

        button.calc-btn {
            padding: 8px 12px;
            font-size: 20px;
            background: #3251BC;
            color: #fff;
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 6px;
            cursor: pointer;
            white-space: nowrap;
            font-weight: 600;
            -webkit-appearance: none;
            appearance: none;
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25) inset, 0 8px 20px rgba(0, 0, 0, 0.10);
            transition: transform 0.06s ease, filter 0.18s ease, box-shadow 0.18s ease;
        }

        button.calc-btn:hover {
            filter: brightness(1.02);
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25) inset, 0 10px 24px rgba(0, 0, 0, 0.12);
        }

        button.calc-btn:active {
            transform: scale(0.98);
            filter: brightness(0.98);
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.18) inset, 0 6px 14px rgba(0, 0, 0, 0.10);
        }

        button.calc-btn:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.35), 0 10px 24px rgba(0, 0, 0, 0.12);
        }

        button.calc-btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            filter: none;
            box-shadow: none;
        }

        .toggle-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            margin: 14px 0 10px;
            font-size: 16px;
        }

        .toggle-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .switch {
            position: relative;
            width: 46px;
            height: 24px;
            background: #ccc;
            border-radius: 24px;
            cursor: pointer;
            transition: background 0.2s;
            flex: 0 0 auto;
        }

        .switch::after {
            content: "";
            top: 2px;
            left: 2px;
            position: absolute;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: left 0.2s;
        }

        .switch.on {
            background: #2196F3;
        }

        .switch.on::after {
            left: 24px;
        }

        .race-focus {
            display: none;
            gap: 8px;
            flex-wrap: nowrap;
            overflow-x: auto;
            padding: 6px 0 10px;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .race-focus::-webkit-scrollbar {
            display: none;
            height: 0;
        }

        .race-focus button {
            border: 1px solid #cfcfcf;
            background: #fff;
            color: #222;
            border-radius: 999px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            white-space: nowrap;
            flex: 0 0 auto;
        }

        .race-focus button.on {
            border-color: #0078d4;
            color: #0078d4;
            font-weight: bold;
        }

        #raceTables {
            width: 100%;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        #raceTables .race-row {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            width: fit-content;
            padding-bottom: 10px;
        }

        .race-card {
            background: #fff;
            border: 1px solid #d9d9d9;
            border-bottom-color: rgb(227, 229, 235);
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.04);
            flex: 0 0 360px;
        }

        @media (min-width: 1200px) {
            #raceTables .race-row {
                width: 100%;
            }

            .race-card {
                flex: 1 1 0;
                min-width: 240px;
            }
        }

        .race-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 12px;
            border-bottom: 1px solid #e6e6e6;
            background: #fff;
        }

        .race-head-left {
            min-width: 0;
        }

        .race-title {
            font-weight: 700;
            font-size: 16px;
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .race-sub {
            margin-top: 4px;
            font-size: 12px;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .race-sub .surf-dirt {
            color: rgb(135, 76, 17);
        }

        .race-sub .surf-turf {
            color: rgb(102, 187, 106);
        }

        .race-clear {
            border: 1px solid #d0d0d0;
            background: #f7f7f7;
            color: #333;
            border-radius: 12px;
            padding: 7px 10px;
            font-size: 14px;
            cursor: pointer;
            white-space: nowrap;
            flex: 0 0 auto;
        }

        table.shutuba-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            table-layout: fixed;
            font-size: 14px;
        }

        table.shutuba-table thead th {
            position: sticky;
            top: 0;
            z-index: 2;
            background: #ededed;
            color: #777;
            font-weight: 600;
            padding: 5px 1px;
            border-bottom: 1px solid #d9d9d9;
        }

        table.shutuba-table thead th+th {
            border-left: 1px solid #d9d9d9;
        }

        table.shutuba-table tbody td {
            padding: 0;
            border-bottom: 1px solid rgb(227, 229, 235);
            vertical-align: middle;
            background: #fff;
        }

        table.shutuba-table tbody td+td {
            border-left: 1px solid rgb(227, 229, 235);
        }

        table.shutuba-table tbody tr.custom-select:not(.is-empty):not(:has(~ tr.custom-select:not(.is-empty))) td {
            border-bottom: 0;
        }

        .th-col {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 13.014px;
        }

        .th-col .th-title {
            font-size: 13.014px;
            font-weight: 400;
            text-align: center;
            white-space: nowrap;
        }

        .th-col .th-sort {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-top: 2px;
        }

        .th-col .tri-up,
        .th-col .tri-down {
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            opacity: 0.7;
        }

        .th-col .tri-up {
            border-bottom: 7px solid #9a9a9a;
        }

        .th-col .tri-down {
            border-top: 7px solid #9a9a9a;
        }

        th.sortable {
            cursor: pointer;
        }

        th.sortable.sort-asc .tri-up,
        th.sortable.sort-desc .tri-down {
            opacity: 1;
        }

        th.sortable.sort-asc .tri-up {
            border-bottom-color: #666;
            opacity: 1;
        }

        th.sortable.sort-desc .tri-down {
            border-top-color: #666;
            opacity: 1;
        }

        th.sortable .tri-up,
        th.sortable .tri-down {
            opacity: 0.45;
        }

        .th-mark-wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .col-no {
            width: 30px;
        }

        table.shutuba-table tbody td.col-no {
            height: 48px;
            line-height: 48px;
            text-align: center;
            font-size: 12px;
            font-feature-settings: "tnum" 1;
            font-variant-numeric: tabular-nums;
        }

        .col-mark {
            width: 51px;
            text-align: center;
        }

        table.shutuba-table tbody td.col-mark {
            background: rgb(222, 224, 229);
        }

        .selected {
            display: block;
            width: 40px;
            height: 36px;
            line-height: 36px;
            margin: 0 auto;
            border-radius: 8px;
            border: 1px solid rgb(136, 136, 136);
            background: rgb(222, 224, 229);
            font-size: 19.081px;
            font-weight: 600;
            color: rgb(17, 17, 17);
            text-align: center;
        }

        .selected.is-marked {
            background-color: #ec5754 !important;
            color: #fff !important;
            border-color: #ec5754 !important;
        }

        .custom-select.has-mark td.col-mark,
        .custom-select.has-mark td.col-info,
        .custom-select.has-mark td.col-odds {
            background: #ffebed;
        }

        .col-info {
            width: auto;
        }

        table.shutuba-table thead th.col-info {
            text-align: center;
        }

        table.shutuba-table tbody td.col-info {
            background: rgb(222, 224, 229);
        }

        .info-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            min-width: 0;
        }

        .horse-name {
            font-weight: bold;
            font-size: 16.8008px;
            color: rgb(0, 51, 170);
            line-height: 16.8008px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
        }

        .info-bottom {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
            min-width: 0;
        }

        .jockey-wrap {
            display: inline-flex;
            align-items: baseline;
            gap: 8px;
            white-space: nowrap;
            flex: 0 0 auto;
        }

        .jockey-name {
            color: rgb(0, 51, 170);
            font-size: 13.0807px;
            padding: 0px 5px;
            margin-right: 3px;
            border-radius: 10px;
        }

        .col-odds {
            width: 67.9844px;
            font-feature-settings: "tnum" 1;
            font-variant-numeric: tabular-nums;
        }

        table.shutuba-table thead th.col-odds {
            text-align: center;
            padding: 5px 1px;
        }

        table.shutuba-table tbody td.col-odds {
            text-align: center;
            background: rgb(222, 224, 229);
        }

        .odds-top {
            display: block;
            font-weight: 700;
            font-size: 12.0006px;
            line-height: 12.0006px;
            color: #555;
            white-space: nowrap;
            text-align: center;
        }

        .odds-top.is-hot {
            color: #c62828;
        }

        .odds-bottom {
            display: inline-block;
            font-weight: 600;
            font-size: 11.0406px;
            line-height: 11.0406px;
            color: #7a7a7a;
            white-space: nowrap;
            text-align: center;
        }

        .is-empty {
            display: none;
        }

        .combo-grid {
            display: grid;
            grid-template-columns: 32px repeat(5, max-content) max-content;
            column-gap: 0;
            row-gap: 2px;
            padding: 4px 0;
        }

        .combo-row {
            display: contents;
        }

        .combo-check-wrap,
        .combo-cell {
            min-height: 32px;
            display: flex;
            align-items: center;
        }

        .combo-cell {
            white-space: nowrap;
            padding: 0 12px;
            border-radius: 0;
        }

        .combo-count {
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            white-space: nowrap;
            padding: 0 12px 0 8px;
            font-size: 16px;
            color: #7a7a7a;
        }

        .combo-check-wrap {
            justify-content: center;
            padding: 0 4px;
            cursor: pointer;
        }

        .combo-check {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .combo-check-visual {
            width: 24px;
            height: 24px;
            border-radius: 8px;
            background-color: #f3f3f3;
            border: 1px solid #d5d5d5;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            color: #c5c5c5;
        }

        .combo-row.checked .combo-check-wrap,
        .combo-row.checked .combo-cell,
        .combo-row.checked .combo-count {
            background-color: #fff0f0;
        }

        .combo-row.checked .combo-check-visual {
            background-color: #ec5754;
            border-color: #ec5754;
            color: #ffffff;
        }

        #result {
            margin-top: 16px;
            font-weight: bold;
            font-size: 18px;
        }

        #combos {
            margin-top: 10px;
            font-size: 20px;
            white-space: normal;
            word-break: keep-all;
            overflow-x: auto;
            display: block;
            padding-bottom: calc(280px + env(safe-area-inset-bottom));
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        #combos:empty {
            padding-bottom: 0;
        }

        #combos::-webkit-scrollbar {
            display: none;
            height: 0;
        }

        .button-row {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 14px;
            width: 100%;
        }

        #minFav {
            font-size: 16px;
            padding: 7px 10px;
            border: 1px solid #cfcfcf;
            border-radius: 6px;
            background-color: #fff;
            color: #222;
            box-sizing: border-box;
        }

        .menu-container {
            position: relative;
            margin-bottom: 10px;
        }

        .menu-button {
            background: #3251BC;
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            display: inline-block;
            border: 1px solid rgba(0, 0, 0, 0.06);
            -webkit-appearance: none;
            appearance: none;
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25) inset, 0 8px 20px rgba(0, 0, 0, 0.10);
            transition: transform 0.06s ease, filter 0.18s ease, box-shadow 0.18s ease;
        }

        .menu-button:hover {
            filter: brightness(1.02);
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25) inset, 0 10px 24px rgba(0, 0, 0, 0.12);
        }

        .menu-button:active {
            transform: scale(0.98);
            filter: brightness(0.98);
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.18) inset, 0 6px 14px rgba(0, 0, 0, 0.10);
        }

        .menu-button:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.35), 0 10px 24px rgba(0, 0, 0, 0.12);
        }

        .menu-icon {
            font-size: 28px;
            line-height: 1;
            display: inline-block;
        }

        .menu-list {
            display: none;
            position: absolute;
            top: 45px;
            left: 0;
            background: white;
            border: 1px solid #ccc;
            border-radius: 6px;
            min-width: 140px;
            z-index: 999;
        }

        .menu-list a {
            display: block;
            padding: 10px 14px;
            color: #333;
            border-bottom: 1px solid #eee;
            text-decoration: none;
        }

        .menu-list a:last-child {
            border-bottom: none;
        }

        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20000;
            padding: 14px;
        }

        .modal-card {
            width: min(720px, 100%);
            background: #fff;
            border-radius: 14px;
            border: 1px solid #d7d7d7;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
            padding: 14px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .modal-help {
            font-size: 13px;
            color: #555;
            margin-top: 8px;
            line-height: 1.35;
            user-select: text !important;
            -webkit-user-select: text !important;
        }

        .modal-textarea {
            width: 100%;
            min-height: 120px;
            font-size: 13px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-sizing: border-box;
            resize: vertical;
            user-select: text !important;
            -webkit-user-select: text !important;
        }

        .modal-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .modal-actions .calc-btn {
            font-size: 16px;
            padding: 8px 12px;
        }

        @media (hover: none) and (pointer: coarse) {
            .modal-textarea {
                font-size: 16px;
            }
        }

        @media (max-width: 640px) {
            body {
                margin: 10px;
            }

            #raceTables {
                touch-action: pan-y;
            }

            .race-card {
                flex: 0 0 calc(100vw - 20px);
            }

            .race-focus {
                display: flex;
            }

            .top-bar-right {
                justify-content: flex-start;
            }

            #win5TabSelect,
            button.calc-btn {
                flex: 1 1 auto;
                min-width: 0;
            }

            button.calc-btn {
                width: 100%;
            }

            body[data-focus-race="1"] .race-card:not([data-race="1"]) {
                display: none;
            }

            body[data-focus-race="2"] .race-card:not([data-race="2"]) {
                display: none;
            }

            body[data-focus-race="3"] .race-card:not([data-race="3"]) {
                display: none;
            }

            body[data-focus-race="4"] .race-card:not([data-race="4"]) {
                display: none;
            }

            body[data-focus-race="5"] .race-card:not([data-race="5"]) {
                display: none;
            }
        }
    </style>
</head>

<body>
    <div class="menu-container">
        <div class="menu-button" onclick="toggleMenu()">
            <span class="menu-icon">☰</span>
        </div>
        <div class="menu-list" id="globalMenu">
            <a href="./calc.html">買い目計算</a>
            <a href="./shushi.html">収支計算</a>
        </div>
    </div>

    <div class="top-bar-right">
        <select id="win5TabSelect"></select>
        <button class="calc-btn" onclick="loadWin5Data()">データ取得</button>
        <button class="calc-btn" onclick="clearAllHorseNames()">クリア</button>
        <button class="calc-btn" onclick="openShare()">共有</button>
    </div>

    <div class="toggle-container">
        <div class="toggle-row">
            <span>背景選択</span>
            <div id="modeToggle" class="switch"></div>
        </div>
        <div class="toggle-row">
            <span>騎手選択</span>
            <div id="jockeyToggle" class="switch"></div>
        </div>
    </div>

    <div id="raceTables"></div>

    <div style="margin-top:14px; font-size: 16px;">
        本命
        <select id="minFav">
            <option value="1" selected>1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
        </select> 勝
    </div>

    <div class="button-row">
        <button class="calc-btn" onclick="calc()">計算する</button>
    </div>

    <div id="result"></div>
    <div id="combos"></div>

    <div id="shareModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-label="印共有">
        <div class="modal-card" onclick="event.stopPropagation()">
            <div class="modal-title">印を共有</div>
            <textarea id="shareText" class="modal-textarea" spellcheck="false"></textarea>
            <div class="modal-actions">
                <button class="calc-btn" onclick="copyShareText()">コピー</button>
                <button class="calc-btn" onclick="importShareText()">読み込み</button>
                <button class="calc-btn" onclick="closeShare()">閉じる</button>
            </div>
            <div class="modal-help">
                ・コピーしたURLを相手に送ってください。<br>
                ・読み込みでクリップボード内のURLから反映できます。<br>
                ・馬名/騎手/オッズは共有しません。
            </div>
        </div>
    </div>

    <script>
        function toggleMenu() {
            const menu = document.getElementById("globalMenu");
            menu.style.display = (menu.style.display === "block") ? "none" : "block";
        }

        document.addEventListener("click", function (e) {
            const menu = document.getElementById("globalMenu");
            const btn = document.querySelector(".menu-button");
            if (!menu || !btn) return;
            if (!menu.contains(e.target) && !btn.contains(e.target)) {
                menu.style.display = "none";
            }
        });

        const TOTAL_RACES = 5;
        const HORSE_MAX = 18;
        const MARKS = ["", "✓", "◎"];
        const CIRCLES = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮', '⑯', '⑰', '⑱'];
        const STORAGE_KEY = 'win5_state_v9';
        const STORAGE_KEY_OLD = 'win5_state_v8';
        const WIN5_API = "https://win5-proxy.cooopew.workers.dev/";

        let backgroundMode = false;
        const modeBtn = document.getElementById("modeToggle");

        let jockeyLinkMode = false;
        const jockeyBtn = document.getElementById("jockeyToggle");

        const AUTO_JOCKEY_COLORS = ["#b3d1ff", "#ffc800", "#96c78c", "#e0b3ff", "#afdfe4", "#c8ad9d", "#e761a4", "#ffd8a8", "#c2f0ff", "#d7ffd6", "#ffe3f1", "#e7e1ff"];
        let jockeyAutoRefreshPending = false;

        let stableJockeyColorMap = new Map();
        let stableJockeyUsedColors = new Set();

        function getStableJockeyColor(j) {
            const key = normJockey(j);
            if (!key) return null;
            const ex = stableJockeyColorMap.get(key);
            if (ex) return ex;

            let c = null;
            for (let i = 0; i < AUTO_JOCKEY_COLORS.length; i++) {
                const cand = AUTO_JOCKEY_COLORS[i];
                if (!stableJockeyUsedColors.has(cand)) { c = cand; break; }
            }
            if (!c) {
                let i = stableJockeyUsedColors.size;
                while (true) {
                    const cand = `hsl(${(i * 137.508) % 360} 70% 85%)`;
                    if (!stableJockeyUsedColors.has(cand)) { c = cand; break; }
                    i++;
                }
            }
            stableJockeyColorMap.set(key, c);
            stableJockeyUsedColors.add(c);
            return c;
        }


        function normJockey(s) {
            return String(s ?? "").replace(/\s+/g, "").trim();
        }

        function scheduleJockeyAutoRefresh() {
            if (jockeyAutoRefreshPending) return;
            jockeyAutoRefreshPending = true;
            requestAnimationFrame(() => {
                jockeyAutoRefreshPending = false;
                refreshJockeyAutoBg();
            });
        }

        function refreshJockeyAutoBg() {
            const rows = Array.from(document.querySelectorAll('.custom-select:not(.is-empty)'));

            if (!jockeyLinkMode) {
                rows.forEach(r => {
                    if (r) delete r.dataset.jockeyAutoBg;
                    const box = r?.querySelector(".selected");
                    const manual = box?.dataset?.bg;
                    if (manual && manual !== "none") applyBg(r, manual);
                    else applyBg(r, "none");
                });
                return;
            }

            const markedRows = rows.filter(r => r.classList.contains("has-mark"));
            const counts = new Map();
            markedRows.forEach(r => {
                const j = normJockey(r.querySelector(".jockey-name")?.textContent);
                if (!j) return;
                counts.set(j, (counts.get(j) || 0) + 1);
            });

            const dupJockeys = [];
            const seen = new Set();
            markedRows.forEach(r => {
                const j = normJockey(r.querySelector(".jockey-name")?.textContent);
                if (!j || seen.has(j)) return;
                seen.add(j);
                if ((counts.get(j) || 0) >= 2) dupJockeys.push(j);
            });

            const colorMap = new Map();
            for (let i = 0; i < dupJockeys.length; i++) {
                const j = dupJockeys[i];
                colorMap.set(j, getStableJockeyColor(j));
            }

            rows.forEach(r => {
                const box = r?.querySelector(".selected");
                const manual = box?.dataset?.bg;
                if (manual && manual !== "none") {
                    delete r.dataset.jockeyAutoBg;
                    applyBg(r, manual);
                    return;
                }

                const j = normJockey(r.querySelector(".jockey-name")?.textContent);
                const shouldAuto = r.classList.contains("has-mark") && j && ((counts.get(j) || 0) >= 2);

                if (shouldAuto) {
                    const c = colorMap.get(j);
                    r.dataset.jockeyAutoBg = c;
                    applyBg(r, c);
                } else {
                    delete r.dataset.jockeyAutoBg;
                    applyBg(r, "none");
                }
            });

            saveState();
        }


        function updateSwitch() {
            backgroundMode ? modeBtn.classList.add("on") : modeBtn.classList.remove("on");
        }

        modeBtn.addEventListener("click", () => {
            backgroundMode = !backgroundMode;
            updateSwitch();
        });

        updateSwitch();

        function clearAllRowBackgrounds() {

            document.querySelectorAll('.custom-select:not(.is-empty)').forEach(r => {

                if (!r) return;

                delete r.dataset.jockeyAutoBg;

                const box = r.querySelector(".selected");

                if (box) box.dataset.bg = "none";

                applyBg(r, "none");

            });

            saveState();

        }


        function updateJockeySwitch() {
            if (!jockeyBtn) return;
            jockeyLinkMode ? jockeyBtn.classList.add("on") : jockeyBtn.classList.remove("on");
            scheduleJockeyAutoRefresh();
        }

        if (jockeyBtn) {
            jockeyBtn.addEventListener("click", () => {
                jockeyLinkMode = !jockeyLinkMode;
                if (!jockeyLinkMode) clearAllRowBackgrounds();
                updateJockeySwitch();
            });
            updateJockeySwitch();
        }

        function toCircleNumber(num) {
            return CIRCLES[num - 1] || String(num);
        }

        function setOddsHot(el, oddsStr) {
            if (!el) return;
            const s = String(oddsStr ?? "").trim();
            const v = Number(s);
            if (s && Number.isFinite(v) && v > 0 && v < 10) el.classList.add("is-hot");
            else el.classList.remove("is-hot");
        }

        function wakuStyle(v) {
            const s = String(v ?? "").trim();
            const m = s.match(/Waku([1-8])/i);
            const w = m ? Number(m[1]) : Number(s);
            if (!Number.isFinite(w) || w < 1 || w > 8) return null;
            if (w === 1) return { bg: "rgb(255, 255, 255)", fg: "rgb(85, 85, 85)", br: "#bdbdbd" };
            if (w === 2) return { bg: "rgb(34, 34, 34)", fg: "rgb(255, 255, 255)", br: "rgb(34, 34, 34)" };
            if (w === 3) return { bg: "rgb(220, 60, 60)", fg: "rgb(255, 255, 255)", br: "rgb(220, 60, 60)" };
            if (w === 4) return { bg: "rgb(44, 83, 169)", fg: "rgb(255, 255, 255)", br: "rgb(44, 83, 169)" };
            if (w === 5) return { bg: "rgb(228, 202, 59)", fg: "rgb(255, 255, 255)", br: "rgb(228, 202, 59)" };
            if (w === 6) return { bg: "rgb(88, 175, 74)", fg: "rgb(255, 255, 255)", br: "rgb(88, 175, 74)" };
            if (w === 7) return { bg: "rgb(222, 138, 38)", fg: "rgb(255, 255, 255)", br: "rgb(222, 138, 38)" };
            return { bg: "rgb(220, 97, 121)", fg: "rgb(255, 255, 255)", br: "rgb(220, 97, 121)" };
        }

        function setNoBox(el, waku, umaban) {
            if (!el) return;
            const st = wakuStyle(waku);
            const n = String(umaban || "").trim();
            el.textContent = n;
            el.dataset.waku = String(waku || "").trim();
            el.dataset.umaban = n;
            if (!st) {
                el.style.background = "";
                el.style.color = "";
                el.style.borderColor = "";
                return;
            }
            el.style.background = st.bg;
            el.style.color = st.fg;
            el.style.borderColor = "";
        }

        const sortStateByRace = {};

        function updateSortUI(card, key, dir) {
            if (!card) return;
            card.querySelectorAll("th.sortable").forEach(th => {
                th.classList.remove("sort-asc");
                th.classList.remove("sort-desc");
            });
            const th = card.querySelector(`th.sortable[data-sort-key="${key}"]`);
            if (!th) return;
            th.classList.add(dir === 1 ? "sort-asc" : "sort-desc");
        }

        function parseNum(v) {
            const n = Number(String(v ?? "").replace(/[^\d.]/g, ""));
            return Number.isFinite(n) ? n : null;
        }

        function sortRaceTable(raceNum, key, dir) {
            const card = document.querySelector(`.race-card[data-race="${raceNum}"]`);
            const tbody = card?.querySelector("tbody");
            if (!tbody) return;

            const rows = Array.from(tbody.querySelectorAll("tr.custom-select"));
            const getVal = (row) => {
                if (row.classList.contains("is-empty")) return null;
                if (key === "no") return parseNum(row.dataset.umaban) ?? parseNum(row.querySelector("td.col-no")?.textContent) ?? null;
                if (key === "name") return (row.dataset.name || "").trim();
                if (key === "odds") return parseNum(row.dataset.odds);
                return null;
            };

            rows.sort((a, b) => {
                const ae = a.classList.contains("is-empty");
                const be = b.classList.contains("is-empty");
                if (ae && !be) return 1;
                if (!ae && be) return -1;

                const av = getVal(a);
                const bv = getVal(b);

                if (av === null && bv === null) return 0;
                if (av === null) return 1;
                if (bv === null) return -1;

                if (typeof av === "number" && typeof bv === "number") {
                    if (av === bv) return 0;
                    return (av < bv ? -1 : 1) * dir;
                }

                const cmp = String(av).localeCompare(String(bv), "ja");
                if (cmp === 0) return 0;
                return cmp * dir;
            });

            for (const r of rows) tbody.appendChild(r);
            updateSortUI(card, key, dir);
        }

        function bindSortHandlers(card, raceNum) {
            const ths = Array.from(card.querySelectorAll("th.sortable"));
            for (const th of ths) {
                const key = th.dataset.sortKey;
                const up = th.querySelector(".tri-up");

                const setSortAsc = () => {
                    sortStateByRace[raceNum] = { key, dir: 1 };
                    sortRaceTable(raceNum, key, 1);
                };

                if (up) up.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); setSortAsc(); });

                th.addEventListener("click", (e) => {
                    if (e.target && e.target.closest(".th-sort")) return;
                    setSortAsc();
                });
            }
        }

        function applyBg(rowEl, bg) {
            const el = rowEl?.querySelector(".jockey-name");
            if (!el) return;
            if (bg && bg !== "none") el.style.backgroundColor = bg;
            else el.style.backgroundColor = "";
        }

        function applyMarkBackground(rowEl, hasMark) {
            if (!rowEl) return;
            rowEl.classList.toggle("has-mark", !!hasMark);
            const box = rowEl.querySelector(".selected");
            if (!box) return;
            if (hasMark) box.classList.add("is-marked");
            else box.classList.remove("is-marked");

            scheduleJockeyAutoRefresh();
        }

        function openPalette(rowEl, e) {
            const box = rowEl.querySelector(".selected");
            if (!box) return;

            const applyColorToRow = (row, color) => {
                const b = row?.querySelector(".selected");
                if (b) b.dataset.bg = color;
                applyBg(row, color);
            };

            const applyColor = (color) => {
                const c = (color === "none") ? "none" : String(color);
                applyColorToRow(rowEl, c);
                palette.remove();
                saveState();
            };

            const palette = document.createElement("div");
            palette.style.position = "absolute";
            palette.style.zIndex = 9999;
            palette.style.display = "flex";
            palette.style.gap = "10px";
            palette.style.background = "#fff";
            palette.style.border = "1px solid #999";
            palette.style.padding = "10px";
            palette.style.borderRadius = "12px";
            palette.style.boxShadow = "0 4px 10px rgba(0,0,0,0.2)";

            const colors = ["#b3d1ff", "#ffc800", "#96c78c", "#e0b3ff", "#afdfe4", "#c8ad9d", "#e761a4"];
            colors.forEach(c => {
                const btn = document.createElement("div");
                btn.style.width = "36px";
                btn.style.height = "36px";
                btn.style.backgroundColor = c;
                btn.style.border = "1px solid #777";
                btn.style.borderRadius = "8px";
                btn.style.cursor = "pointer";
                btn.addEventListener("click", () => {
                    applyColor(c);
                });
                palette.appendChild(btn);
            });

            const noneBtn = document.createElement("div");
            noneBtn.style.width = "36px";
            noneBtn.style.height = "36px";
            noneBtn.style.background = "#fff";
            noneBtn.style.border = "1px solid #777";
            noneBtn.style.borderRadius = "8px";
            noneBtn.style.cursor = "pointer";
            noneBtn.addEventListener("click", () => {
                applyColor("none");
            });
            palette.appendChild(noneBtn);

            document.body.appendChild(palette);

            const rect = palette.getBoundingClientRect();
            const pw = rect.width;
            const ph = rect.height;
            const vw = window.innerWidth;
            const vh = window.innerHeight;

            let left = e.pageX;
            let top = e.pageY;

            if (left + pw > vw - 10) left = vw - pw - 10;
            if (top + ph > vh - 10) top = vh - ph - 10;

            palette.style.left = left + "px";
            palette.style.top = top + "px";

            const closePalette = (ev) => {
                if (!palette.contains(ev.target)) {
                    palette.remove();
                    document.removeEventListener("click", closePalette, true);
                }
            };

            setTimeout(() => document.addEventListener("click", closePalette, true), 0);
        }



        function createRow(raceNum, horseNum) {
            const tr = document.createElement("tr");
            tr.className = "custom-select";
            tr.dataset.race = String(raceNum);
            tr.dataset.horse = String(horseNum);
            tr.dataset.umaban = "";
            tr.dataset.name = "";
            tr.dataset.jockey = "";
            tr.dataset.odds = "";
            tr.dataset.ninki = "";

            const tdNo = document.createElement("td");
            tdNo.className = "col-no";
            tdNo.textContent = String(horseNum);

            const tdM = document.createElement("td");
            tdM.className = "col-mark";
            const selected = document.createElement("div");
            selected.className = "selected";
            selected.textContent = "";
            selected.dataset.bg = "none";
            tdM.appendChild(selected);

            const tdInfo = document.createElement("td");
            tdInfo.className = "col-info";

            const top = document.createElement("div");
            top.className = "info-top";
            const hName = document.createElement("span");
            hName.className = "horse-name";
            hName.textContent = "";
            top.appendChild(hName);

            const bottom = document.createElement("div");
            bottom.className = "info-bottom";

            const jWrap = document.createElement("span");
            jWrap.className = "jockey-wrap";
            const jName = document.createElement("span");
            jName.className = "jockey-name";
            jName.textContent = "";
            jWrap.appendChild(jName);

            bottom.appendChild(jWrap);

            tdInfo.appendChild(top);
            tdInfo.appendChild(bottom);

            const tdOdds = document.createElement("td");
            tdOdds.className = "col-odds";
            const oTop = document.createElement("span");
            oTop.className = "odds-top";
            oTop.textContent = "";
            const oBottom = document.createElement("span");
            oBottom.className = "odds-bottom";
            oBottom.textContent = "";
            tdOdds.appendChild(oTop);
            tdOdds.appendChild(oBottom);

            const cycleMark = () => {
                const cur = MARKS.indexOf(selected.textContent);
                selected.textContent = MARKS[(cur + 1) % MARKS.length];
                applyMarkBackground(tr, selected.textContent !== "");
                saveState();
            };

            selected.addEventListener("click", (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (backgroundMode) {
                    openPalette(tr, e);
                    return;
                }
                cycleMark();
            });

            tr.addEventListener("click", (e) => {
                if (e.target && e.target.closest(".selected")) return;
                if (backgroundMode) openPalette(tr, e);
                else cycleMark();
            });

            tr.appendChild(tdNo);
            tr.appendChild(tdM);
            tr.appendChild(tdInfo);
            tr.appendChild(tdOdds);

            return tr;
        }

        function createRaceTables() {
            const root = document.getElementById("raceTables");
            root.innerHTML = "";

            const row = document.createElement("div");
            row.className = "race-row";
            root.appendChild(row);

            for (let r = 1; r <= TOTAL_RACES; r++) {
                const card = document.createElement("div");
                card.className = "race-card";
                card.dataset.race = String(r);

                const head = document.createElement("div");
                head.className = "race-head";

                const headLeft = document.createElement("div");
                headLeft.className = "race-head-left";

                const title = document.createElement("div");
                title.className = "race-title";
                title.id = `raceTitle${r}`;
                title.textContent = `WIN${r}`;

                const sub = document.createElement("div");
                sub.className = "race-sub";
                sub.id = `raceSub${r}`;
                sub.textContent = "";

                headLeft.appendChild(title);
                headLeft.appendChild(sub);

                const clearBtn = document.createElement("button");
                clearBtn.type = "button";
                clearBtn.className = "race-clear";
                clearBtn.textContent = "クリア";
                clearBtn.addEventListener("click", () => clearColumn(r));

                head.appendChild(headLeft);
                head.appendChild(clearBtn);

                const table = document.createElement("table");
                table.className = "shutuba-table";

                const thead = document.createElement("thead");
                thead.innerHTML = `
          <tr>
            <th class="col-no sortable" data-sort-key="no">
              <div class="th-col">
                <div class="th-title">馬番</div>
                <div class="th-sort"><span class="tri-up"></span></div>
              </div>
            </th>
            <th class="col-mark">
              <div class="th-col">
                <div class="th-title">予想印</div>
              </div>
            </th>
            <th class="col-info">
              <div class="th-col">
                <div class="th-title">馬名</div>
              </div>
            </th>
            <th class="col-odds sortable" data-sort-key="odds">
              <div class="th-col">
                <div class="th-title">オッズ</div>
                <div class="th-sort"><span class="tri-up"></span></div>
              </div>
            </th>
          </tr>
        `;
                const tbody = document.createElement("tbody");
                for (let i = 1; i <= HORSE_MAX; i++) {
                    tbody.appendChild(createRow(r, i));
                }

                table.appendChild(thead);
                table.appendChild(tbody);

                card.appendChild(head);
                card.appendChild(table);

                bindSortHandlers(card, r);
                row.appendChild(card);
            }
        }

        let lastState = '';
        function saveState() {
            const state = {
                races: {},
                minFav: document.getElementById('minFav').value,
                raceInfo: window.raceInfo || ["", "", "", "", ""],
                raceTimes: window.raceTimes || ["", "", "", "", ""],
                raceCourses: window.raceCourses || ["", "", "", "", ""],
                jockeyLinkMode: !!jockeyLinkMode,
                jockeyColorMap: Array.from(stableJockeyColorMap.entries())
            };

            for (let r = 1; r <= TOTAL_RACES; r++) {
                state.races[`r${r}`] = {};
                document.querySelectorAll(`.custom-select[data-race="${r}"]`).forEach(sel => {
                    const box = sel.querySelector('.selected');
                    const nameEl = sel.querySelector('.horse-name');
                    const jEl = sel.querySelector('.jockey-name');
                    const oEl = sel.querySelector('.odds-top');
                    const pEl = sel.querySelector('.odds-bottom');
                    const noEl = sel.querySelector('td.col-no');


                    const name = (nameEl?.textContent || "").trim();
                    const isEmpty = sel.classList.contains("is-empty");
                    const jockey = (jEl?.textContent || "").trim();
                    const odds = (oEl?.textContent || "").trim();
                    const ninki = (pEl?.textContent || "").trim().replace("人気", "");
                    const waku = (noEl?.dataset.waku || "").trim();
                    const umaban = (noEl?.textContent || "").trim();

                    state.races[`r${r}`][sel.dataset.horse] = {
                        mark: (box?.textContent || "").trim(),
                        bg: (box?.dataset.bg || "none").trim(),
                        jbg: (sel.dataset.jockeyAutoBg || null),
                        name: isEmpty ? null : name,
                        jockey: jockey || null,
                        odds: odds || null,
                        ninki: ninki || null,
                        waku: waku || null,
                        umaban: umaban || null
                    };
                });
            }

            const str = JSON.stringify(state);
            if (str !== lastState) {
                localStorage.setItem(STORAGE_KEY, str);
                lastState = str;
            }
        }

        function restoreState() {
            const data = localStorage.getItem(STORAGE_KEY) || localStorage.getItem(STORAGE_KEY_OLD);
            if (!data) return;

            try {
                const state = JSON.parse(data);

                if (state.raceInfo) window.raceInfo = state.raceInfo;
                if (state.raceTimes) window.raceTimes = state.raceTimes;
                if (state.raceCourses) window.raceCourses = state.raceCourses;

                if (Array.isArray(state.jockeyColorMap)) {
                    stableJockeyColorMap = new Map(state.jockeyColorMap);
                    stableJockeyUsedColors = new Set(Array.from(stableJockeyColorMap.values()));
                }

                if (typeof state.jockeyLinkMode === "boolean") {
                    jockeyLinkMode = !!state.jockeyLinkMode;
                    updateJockeySwitch();
                }

                updateRaceHeaders(window.raceInfo || ["", "", "", "", ""]);

                if (state.minFav) document.getElementById('minFav').value = state.minFav;

                for (let r = 1; r <= TOTAL_RACES; r++) {
                    const race = state.races?.[`r${r}`];
                    if (!race) continue;

                    document.querySelectorAll(`.custom-select[data-race="${r}"]`).forEach(sel => {
                        const val = race?.[sel.dataset.horse];
                        if (!val) return;

                        const box = sel.querySelector('.selected');
                        const nameEl = sel.querySelector('.horse-name');
                        const jEl = sel.querySelector('.jockey-name');
                        const oEl = sel.querySelector('.odds-top');
                        const pEl = sel.querySelector('.odds-bottom');
                        const noEl = sel.querySelector('td.col-no');


                        const m = (val.mark || "").toString();
                        const b = (val.bg || "none").toString();
                        const jbg = (val.jbg || "").toString();

                        if (jbg) sel.dataset.jockeyAutoBg = jbg;
                        else delete sel.dataset.jockeyAutoBg;

                        if (box) {
                            box.textContent = m;
                            box.dataset.bg = b;
                        }

                        applyMarkBackground(sel, !!m);
                        const effBg = (b && b !== "none") ? b : ((jockeyLinkMode && jbg) ? jbg : "none");
                        applyBg(sel, effBg);
                        const name = val.name;
                        if (name === null) {
                            sel.classList.add("is-empty");
                            if (nameEl) nameEl.textContent = "";
                            if (jEl) jEl.textContent = "";
                            if (oEl) {
                                oEl.textContent = "";
                                setOddsHot(oEl, "");
                            }
                            if (pEl) pEl.textContent = "";
                            if (noEl) setNoBox(noEl, "", "");
                            sel.dataset.umaban = "";
                            sel.dataset.name = "";
                            sel.dataset.jockey = "";
                            sel.dataset.odds = "";
                            sel.dataset.ninki = "";
                            sel.dataset.umaban = "";
                            sel.dataset.name = "";
                            sel.dataset.jockey = "";
                            sel.dataset.odds = "";
                            sel.dataset.ninki = "";
                            if (box) {
                                box.textContent = "";
                                box.dataset.bg = "none";
                            }
                            applyMarkBackground(sel, false);
                            applyBg(sel, "none");
                            return;
                        }

                        sel.classList.remove("is-empty");
                        if (nameEl) nameEl.textContent = String(name);
                        if (jEl) jEl.textContent = (val.jockey || "") ? String(val.jockey) : "";
                        if (oEl) {
                            oEl.textContent = (val.odds || "") ? String(val.odds) : "";
                            setOddsHot(oEl, oEl.textContent);
                        }
                        if (pEl) pEl.textContent = (val.ninki || "") ? (String(val.ninki) + "人気") : "";
                        if (noEl) setNoBox(noEl, (val.waku || "") ? String(val.waku) : "", (val.umaban || "") ? String(val.umaban) : String(sel.dataset.horse));
                        sel.dataset.umaban = (val.umaban || "") ? String(val.umaban).trim() : "";
                        sel.dataset.name = String(name || "").trim();
                        sel.dataset.jockey = (val.jockey || "") ? String(val.jockey).trim() : "";
                        sel.dataset.odds = (val.odds || "") ? String(val.odds).trim() : "";
                        sel.dataset.ninki = (val.ninki || "") ? String(val.ninki).trim() : "";
                    });
                }
            } catch (e) { }
        }

        function clearColumn(colNum) {
            document.querySelectorAll(`.custom-select[data-race="${colNum}"]`).forEach(sel => {
                const box = sel.querySelector(".selected");
                if (box) {
                    box.textContent = "";
                    box.dataset.bg = "none";
                }
                applyMarkBackground(sel, false);
                applyBg(sel, "none");
            });
            saveState();
        }

        function clearAllHorseNames() {
            document.querySelectorAll('.custom-select').forEach(sel => {
                sel.classList.remove("is-empty");

                const nameEl = sel.querySelector('.horse-name');
                const jEl = sel.querySelector('.jockey-name');
                const oEl = sel.querySelector('.odds-top');
                const pEl = sel.querySelector('.odds-bottom');
                const noEl = sel.querySelector('td.col-no');

                const box = sel.querySelector('.selected');

                if (nameEl) nameEl.textContent = "";
                if (jEl) jEl.textContent = "";
                if (oEl) {
                    oEl.textContent = "";
                    setOddsHot(oEl, "");
                }
                if (pEl) pEl.textContent = "";
                if (noEl) setNoBox(noEl, "", String(sel.dataset.horse));
                sel.dataset.umaban = "";
                sel.dataset.name = "";
                sel.dataset.jockey = "";
                sel.dataset.odds = "";
                sel.dataset.ninki = "";

                if (box) {
                    box.textContent = "";
                    box.dataset.bg = "none";
                }
                applyMarkBackground(sel, false);
                applyBg(sel, "none");
            });

            window.raceInfo = ["", "", "", "", ""];
            window.raceTimes = ["", "", "", "", ""];
            window.raceCourses = ["", "", "", "", ""];
            updateRaceHeaders(window.raceInfo);

            saveState();
        }

        function getRaceData(r) {
            const favs = [], himo = [], colorMap = {};
            document.querySelectorAll(`.custom-select[data-race="${r}"]`).forEach(sel => {
                if (sel.classList.contains("is-empty")) return;
                const box = sel.querySelector('.selected');
                const v = (box?.textContent || "").trim();

                let bg = (box?.dataset.bg || "none").trim();
                if ((!bg || bg === "none") && jockeyLinkMode) {
                    const auto = (sel.dataset.jockeyAutoBg || "").trim();
                    if (auto) bg = auto;
                }

                const num = Number(sel.dataset.horse);
                colorMap[num] = bg;
                if (v === "◎") favs.push(num);
                if (v === "✓") himo.push(num);
            });
            const all = [...new Set([...favs, ...himo])];
            return { fav: favs, horse: all, colorMap };
        }

        function combinations(arr, k) {
            const res = [];
            (function h(s, c) {
                if (c.length === k) {
                    res.push([...c]);
                    return;
                }
                for (let i = s; i < arr.length; i++) {
                    c.push(arr[i]);
                    h(i + 1, c);
                    c.pop();
                }
            })(0, []);
            return res;
        }

        function attachComboEvents() {
            document.querySelectorAll('#combos .combo-check').forEach(chk => {
                chk.addEventListener('change', () => {
                    const row = chk.closest('.combo-row');
                    if (!row) return;
                    if (chk.checked) row.classList.add('checked');
                    else row.classList.remove('checked');
                });
            });
        }

        function calc() {
            const races = [], favs = [], colorArray = [];

            for (let i = 1; i <= TOTAL_RACES; i++) {
                const d = getRaceData(i);
                races.push(d.horse);
                favs.push(d.fav);
                const colors = new Array(HORSE_MAX + 1);
                for (let h = 1; h <= HORSE_MAX; h++) colors[h] = d.colorMap[h] || "none";
                colorArray.push(colors);
            }

            const favMaskList = favs.map(a => a.map(x => 1 << (x - 1)));
            const nonFavMaskList = races.map((a, idx) => {
                const favSet = new Set(favs[idx]);
                return a.filter(x => !favSet.has(x)).map(x => 1 << (x - 1));
            });

            const colorIdTable = Array.from({ length: TOTAL_RACES }, () => new Int16Array(HORSE_MAX).fill(-1));
            const colorIdMap = new Map();
            let nextColorId = 0;

            for (let i = 0; i < TOTAL_RACES; i++) {
                const usedHorses = races[i];
                for (let idx = 0; idx < usedHorses.length; idx++) {
                    const h = usedHorses[idx];
                    const c = colorArray[i][h];
                    if (c && c !== "none") {
                        let id = colorIdMap.get(c);
                        if (id === undefined) {
                            id = nextColorId++;
                            colorIdMap.set(c, id);
                        }
                        colorIdTable[i][h - 1] = id;
                    }
                }
            }

            const masksCache = {};
            function getMasks(k) {
                if (!masksCache[k]) masksCache[k] = combinations([...Array(TOTAL_RACES).keys()], k);
                return masksCache[k];
            }

            function countCombosDFS(candidates) {
                const n = candidates.length;

                const order = Array.from({ length: n }, (_, i) => i).sort((a, b) => candidates[a].length - candidates[b].length);

                const revOrder = new Int8Array(n);
                for (let i = 0; i < n; i++) revOrder[order[i]] = i;

                const candColorIds = new Array(n);
                for (let r = 0; r < n; r++) {
                    const arr = candidates[r];
                    const ids = new Int16Array(arr.length);
                    for (let i = 0; i < arr.length; i++) {
                        const bit = arr[i];
                        const idx = Math.log2(bit) | 0;
                        ids[i] = colorIdTable[r][idx];
                    }
                    candColorIds[r] = ids;
                }

                let count = 0;
                const blocks = [];
                const path = new Int32Array(n);

                const dfs = (depth, usedColorMask) => {
                    if (depth === n) {
                        count++;
                        const combo = new Array(n);
                        for (let i = 0; i < n; i++) combo[i] = path[revOrder[i]];
                        blocks.push(combo);
                        return;
                    }

                    const raceIdx = order[depth];
                    const arr = candidates[raceIdx];
                    const colorIds = candColorIds[raceIdx];

                    for (let k = 0; k < arr.length; k++) {
                        const m = arr[k];
                        const colorId = colorIds[k];

                        if (colorId >= 0 && (usedColorMask & (1 << colorId))) continue;

                        path[depth] = m;
                        const nextMask = (colorId >= 0) ? (usedColorMask | (1 << colorId)) : usedColorMask;
                        dfs(depth + 1, nextMask);
                    }
                };

                dfs(0, 0);
                return { count, blocks };
            }

            const minFav = Number(document.getElementById('minFav').value);
            let total = 0;
            const comboList = [];

            const k = minFav;
            const masks = getMasks(k);
            let count = 0;
            let blocks = [];

            for (let m = 0; m < masks.length; m++) {
                const maskArr = masks[m];
                const maskSet = new Set(maskArr);
                const candidates = new Array(TOTAL_RACES);
                let valid = true;

                for (let i = 0; i < TOTAL_RACES; i++) {
                    candidates[i] = maskSet.has(i) ? favMaskList[i] : nonFavMaskList[i];
                    if (candidates[i].length === 0) { valid = false; break; }
                }
                if (!valid) continue;

                const res = countCombosDFS(candidates);
                count += res.count;

                for (let i = 0; i < res.blocks.length; i++) {
                    blocks.push(res.blocks[i]);
                }
            }

            const displayBlocks = fullyMergeBlocksStableBit(blocks);
            comboList.push('<div class="combo-grid">');
            for (const b of displayBlocks) comboList.push(blockToLineBit(b));
            comboList.push('</div>');

            total = count;

            document.getElementById('result').innerHTML =
                `買い目：<span style="color:#0078d4;">${total.toLocaleString()}</span> 組`;

            const combosEl = document.getElementById('combos');
            const combosHtml = comboList.join('');

            if (!combosHtml.trim()) {
                combosEl.replaceChildren();
            } else {
                const container = document.createElement('div');
                container.innerHTML = combosHtml;
                combosEl.replaceChildren(container);
                attachComboEvents();
            }
            saveState();
        }

        function fullyMergeBlocksStableBit(blocks) {
            const n = TOTAL_RACES | 0;
            if (blocks.length <= 1) return blocks;

            let changed = true;
            while (changed) {
                changed = false;

                for (let d = 0; d < n; d++) {
                    const len = blocks.length;
                    if (len <= 1) break;

                    const map = new Map();
                    for (let i = 0; i < len; i++) {
                        const b = blocks[i];
                        let key = "";
                        for (let k = 0; k < n; k++) {
                            if (k === d) continue;
                            key += b[k] + ",";
                        }
                        let arr = map.get(key);
                        if (!arr) {
                            arr = [];
                            map.set(key, arr);
                        }
                        arr.push(i);
                    }

                    const used = new Uint8Array(len);
                    const next = [];

                    for (let i = 0; i < len; i++) {
                        if (used[i]) continue;

                        const baseRow = blocks[i];
                        let key = "";
                        for (let k = 0; k < n; k++) {
                            if (k === d) continue;
                            key += baseRow[k] + ",";
                        }
                        const group = map.get(key);

                        if (!group || group.length === 1) {
                            next.push(baseRow);
                            used[i] = 1;
                            continue;
                        }

                        let mergedRow = baseRow.slice();
                        used[i] = 1;

                        for (let gi = 0; gi < group.length; gi++) {
                            const j = group[gi];
                            if (j === i || used[j]) continue;

                            const row = blocks[j];
                            if ((mergedRow[d] & row[d]) === 0) {
                                mergedRow[d] |= row[d];
                                used[j] = 1;
                                changed = true;
                            }
                        }

                        next.push(mergedRow);
                    }

                    blocks = next;
                }
            }
            return blocks;
        }

        function blockToLineBit(block) {
            const bitCount = (m) => {
                let x = (m >>> 0);
                let c = 0;
                while (x) {
                    x &= x - 1;
                    c++;
                }
                return c;
            };

            let rowCount = 1;
            for (let i = 0; i < block.length; i++) {
                rowCount *= bitCount(block[i]);
            }
            const countLabel = rowCount.toLocaleString();

            const parts = block.map(mask => {
                const nums = [];
                for (let i = 0; i < HORSE_MAX; i++) {
                    if (mask & (1 << i)) nums.push(toCircleNumber(i + 1));
                }
                return nums.join('');
            });
            const cells = parts.map(p => `<span class="combo-cell">${p}</span>`).join('');
            return (
                '<div class="combo-row">' +
                '<label class="combo-check-wrap">' +
                '<input type="checkbox" class="combo-check">' +
                '<span class="combo-check-visual">✓</span>' +
                '</label>' +
                cells +
                `<span class="combo-count">${countLabel}組</span>` +
                '</div>'
            );
        }

        function escapeHtml(s) {
            return String(s ?? "").replace(/[&<>"']/g, ch => {
                if (ch === "&") return "&amp;";
                if (ch === "<") return "&lt;";
                if (ch === ">") return "&gt;";
                if (ch === '"') return "&quot;";
                return "&#39;";
            });
        }

        function colorizeCourse(course) {
            const c = String(course ?? "").trim();
            if (!c) return "";
            const first = c[0];
            const rest = c.slice(1);
            if (first === "ダ") return `<span class="surf-dirt">ダ</span>${escapeHtml(rest)}`;
            if (first === "芝") return `<span class="surf-turf">芝</span>${escapeHtml(rest)}`;
            return escapeHtml(c);
        }

        function updateRaceHeaders(raceInfo) {
            const raceTimes = window.raceTimes || [];
            const raceCourses = window.raceCourses || [];

            for (let i = 0; i < 5; i++) {
                const title = document.getElementById(`raceTitle${i + 1}`);
                const sub = document.getElementById(`raceSub${i + 1}`);

                const time = (raceTimes[i] || "").trim();
                const course = (raceCourses[i] || "").trim();
                const info = (raceInfo && raceInfo[i]) ? String(raceInfo[i]).trim() : "";

                const label = info ? info : `WIN${i + 1}`;
                if (title) title.textContent = label;

                if (sub) {
                    if (time && course) sub.innerHTML = `${escapeHtml(time)} ${colorizeCourse(course)}`;
                    else if (time) sub.textContent = `${time}`;
                    else if (course) sub.innerHTML = colorizeCourse(course);
                    else sub.textContent = "";
                }
            }
        }

        function applyWin5Data(json) {
            window.raceInfo = json.raceInfo || [];
            window.raceTimes = json.raceTimes || ((json.races || []).map(r => (r && r.startTime) ? String(r.startTime) : ""));
            window.raceCourses = json.raceCourses || ((json.races || []).map(r => (r && (r.courseInfo || r.course || r.courseText)) ? String(r.courseInfo || r.course || r.courseText) : ""));
            updateRaceHeaders(window.raceInfo);

            const races = json.races || [];

            for (let r = 0; r < TOTAL_RACES; r++) {
                const horses = (races[r] && races[r].horses) ? races[r].horses : [];
                const jockeys = (races[r] && races[r].jockeys) ? races[r].jockeys : [];
                const oddsArr = (races[r] && races[r].odds) ? races[r].odds : [];
                const ninkiArr = (races[r] && races[r].ninki) ? races[r].ninki : [];
                const wakubans = (races[r] && races[r].wakubans) ? races[r].wakubans : [];
                const wakuClasses = (races[r] && races[r].wakuClasses) ? races[r].wakuClasses : [];
                const umabans = (races[r] && races[r].umabans) ? races[r].umabans : [];

                for (let i = 1; i <= HORSE_MAX; i++) {
                    const raceNum = r + 1;
                    const horseNum = i;

                    const name = horses[i - 1] || "";
                    const jockey = jockeys[i - 1] || "";
                    const odds = oddsArr[i - 1];
                    const ninki = ninkiArr[i - 1];
                    const wakuClass = wakuClasses[i - 1] || "";
                    const waku = wakuClass || (wakubans[i - 1] || "");
                    const umaban = umabans[i - 1] || String(i);

                    const sel = document.querySelector(`.custom-select[data-race="${raceNum}"][data-horse="${horseNum}"]`);
                    if (!sel) continue;

                    const nameEl = sel.querySelector(".horse-name");
                    const jEl = sel.querySelector(".jockey-name");
                    const oEl = sel.querySelector(".odds-top");
                    const pEl = sel.querySelector(".odds-bottom");
                    const noEl = sel.querySelector("td.col-no");
                    const box = sel.querySelector(".selected");

                    if (name) {
                        sel.classList.remove("is-empty");
                        if (nameEl) nameEl.textContent = String(name);
                        if (jEl) jEl.textContent = String(jockey || "");
                        if (oEl) {
                            const oTxt = (odds === undefined || odds === null) ? "" : String(odds);
                            oEl.textContent = oTxt;
                            setOddsHot(oEl, oTxt);
                        }
                        if (pEl) {
                            const pTxt = (ninki === undefined || ninki === null || ninki === "") ? "" : `${String(ninki)}人気`;
                            pEl.textContent = pTxt;
                        }
                        if (noEl) setNoBox(noEl, String(waku || ""), String(umaban || ""));
                        sel.dataset.umaban = String(umaban || "").trim();
                        sel.dataset.name = String(name || "").trim();
                        sel.dataset.jockey = String(jockey || "").trim();
                        sel.dataset.odds = (odds === undefined || odds === null) ? "" : String(odds).trim();
                        sel.dataset.ninki = (ninki === undefined || ninki === null) ? "" : String(ninki).trim();
                    } else {
                        sel.classList.add("is-empty");

                        if (nameEl) nameEl.textContent = "";
                        if (jEl) jEl.textContent = "";
                        if (oEl) {
                            oEl.textContent = "";
                            setOddsHot(oEl, "");
                        }
                        if (pEl) pEl.textContent = "";
                        if (noEl) setNoBox(noEl, "", "");
                        sel.dataset.umaban = "";
                        sel.dataset.name = "";
                        sel.dataset.jockey = "";
                        sel.dataset.odds = "";
                        sel.dataset.ninki = "";

                        if (box) {
                            box.textContent = "";
                            box.dataset.bg = "none";
                        }
                        applyMarkBackground(sel, false);
                        applyBg(sel, "none");
                    }
                }
            }

            saveState();
        }

        async function loadWin5Data() {
            const idx = document.getElementById("win5TabSelect").value;

            const u = new URL(WIN5_API);
            u.searchParams.set("tab", idx);
            u.searchParams.set("_", String(Date.now()));

            const res = await fetch(u.toString(), { cache: "no-store" });
            const json = await res.json();

            if (!json.ok) return;

            applyWin5Data(json);
        }

        async function loadWin5Tabs() {
            const u = new URL(WIN5_API);
            u.searchParams.set("_", String(Date.now()));

            const res = await fetch(u.toString(), { cache: "no-store" });
            const json = await res.json();

            if (!json.ok) return;

            const tabs = json.tabs || [];
            const current = json.activeTab ?? 0;

            const select = document.getElementById("win5TabSelect");
            if (!select) return;

            select.innerHTML = "";

            tabs.forEach((t, i) => {
                const op = document.createElement("option");
                op.value = i;
                op.textContent = t.label;
                if (i === current) op.selected = true;
                select.appendChild(op);
            });
        }

        function openShare() {
            const modal = document.getElementById("shareModal");
            const ta = document.getElementById("shareText");
            if (!modal || !ta) return;

            const payload = buildSharePayload();
            const token = encodeSharePayload(payload);

            const base = location.href.split("#")[0];
            const url = `${base}#share=${token}`;

            ta.value = url;

            modal.style.display = "flex";
            document.body.style.overflow = "hidden";
            modal.onclick = () => closeShare();
            const isCoarse = window.matchMedia("(hover: none) and (pointer: coarse)").matches;
            if (!isCoarse) {
                ta.focus();
                ta.select();
            }
        }

        function closeShare() {
            const modal = document.getElementById("shareModal");
            if (modal) modal.style.display = "none";
            document.body.style.overflow = "";
        }

        async function copyShareText() {
            const ta = document.getElementById("shareText");
            if (!ta) return;
            const txt = ta.value || "";
            if (!txt) return;

            try {
                await navigator.clipboard.writeText(txt);
            } catch (e) {
                const isCoarse = window.matchMedia("(hover: none) and (pointer: coarse)").matches;
                if (!isCoarse) {
                    ta.focus();
                    ta.select();
                }
                document.execCommand("copy");
            }
        }

        async function importShareText() {
            const ta = document.getElementById("shareText");
            if (!ta) return;

            let token = null;

            try {
                const clip = (await navigator.clipboard.readText()) || "";
                const t = extractShareToken(clip.trim());
                if (t) token = t;
            } catch (e) { }

            const base = location.href.split("#")[0];
            const currentUrl = `${base}#share=${encodeSharePayload(buildSharePayload())}`;

            if (!token) {
                const raw = (ta.value || "").trim();
                if (!raw) return;
                if (raw === currentUrl) return;
                token = extractShareToken(raw);
            }

            if (!token) return;

            try {
                const payload = decodeSharePayload(token);
                applySharePayload(payload);
                closeShare();
            } catch (e) { }
        }

        function extractShareToken(txt) {
            const t = (txt || "").trim();
            const m = t.match(/[?#&]share=([A-Za-z0-9\-_]+)/);
            if (m) return m[1];
            if (/^[A-Za-z0-9\-_]{20,}$/.test(t)) return t;
            return null;
        }

        function buildSharePayload() {
            const items = [];
            document.querySelectorAll(".custom-select").forEach(sel => {
                if (sel.classList.contains("is-empty")) return;
                const r = Number(sel.dataset.race);
                const h = Number(sel.dataset.horse);
                const box = sel.querySelector(".selected");
                const mark = (box?.textContent || "").trim();
                const bg = (box?.dataset.bg || "none").trim();

                if (mark || (bg && bg !== "none")) {
                    items.push([r, h, mark, bg]);
                }
            });
            return { v: 1, items };
        }

        function applySharePayload(payload) {
            if (!payload || payload.v !== 1 || !Array.isArray(payload.items)) return;

            document.querySelectorAll(".custom-select").forEach(sel => {
                const box = sel.querySelector(".selected");
                if (!box) return;
                box.textContent = "";
                box.dataset.bg = "none";
                applyMarkBackground(sel, false);
                applyBg(sel, "none");
            });

            for (const it of payload.items) {
                if (!Array.isArray(it) || it.length < 4) continue;
                const [r, h, mark, bg] = it;

                const sel = document.querySelector(`.custom-select[data-race="${r}"][data-horse="${h}"]`);
                if (!sel || sel.classList.contains("is-empty")) continue;

                const box = sel.querySelector(".selected");
                if (!box) continue;

                const m = (mark || "").toString();
                const b = (bg || "none").toString();

                box.textContent = m;
                applyMarkBackground(sel, !!m);

                box.dataset.bg = b;
                applyBg(sel, b);
            }

            saveState();
        }

        function encodeSharePayload(obj) {
            const json = JSON.stringify(obj);
            const b64 = btoa(unescape(encodeURIComponent(json)));
            return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
        }

        function decodeSharePayload(token) {
            const t = token.replace(/-/g, "+").replace(/_/g, "/");
            const pad = t.length % 4 ? "=".repeat(4 - (t.length % 4)) : "";
            const json = decodeURIComponent(escape(atob(t + pad)));
            return JSON.parse(json);
        }

        function applyShareFromURL() {
            const hash = location.hash || "";
            const m = hash.match(/share=([A-Za-z0-9\-_]+)/);
            if (!m) return;

            try {
                const payload = decodeSharePayload(m[1]);
                applySharePayload(payload);
                const base = location.href.split("#")[0];
                history.replaceState(null, "", base);
            } catch (e) { }
        }

        function isMobileLayout() {
            return window.matchMedia("(max-width: 640px)").matches;
        }

        function applyRaceFocus(v) {
            const b = document.body;
            const s = String(v || "all");
            if (s === "all") {
                b.removeAttribute("data-focus-race");
                return;
            }
            b.setAttribute("data-focus-race", s);
        }

        function initMobileSwipe() {
            const root = document.getElementById("raceTables");
            if (!root) return;

            const mq = window.matchMedia("(max-width: 640px) and (hover: none) and (pointer: coarse)");
            if (initMobileSwipe._bound !== true) {
                const onChange = () => initMobileSwipe();
                if (mq.addEventListener) mq.addEventListener("change", onChange);
                else if (mq.addListener) mq.addListener(onChange);
                initMobileSwipe._bound = true;
            }

            if (initMobileSwipe._abort && initMobileSwipe._abort.abort) {
                initMobileSwipe._abort.abort();
            }
            initMobileSwipe._abort = null;

            if (!mq.matches) return;

            const ac = (typeof AbortController !== "undefined") ? new AbortController() : null;
            initMobileSwipe._abort = ac;

            let sx = 0;
            let sy = 0;
            let active = false;
            let lock = false;

            const start = (e) => {
                const t = e.touches ? e.touches[0] : null;
                if (!t) return;
                sx = t.clientX;
                sy = t.clientY;
                active = true;
                lock = false;
            };

            const move = (e) => {
                if (!active) return;
                if (!e.touches || e.touches.length !== 1) return;

                const t = e.touches[0];
                const dx = t.clientX - sx;
                const dy = t.clientY - sy;

                if (!lock) {
                    if (Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)) lock = true;
                    else return;
                }

                e.preventDefault();
            };

            const end = (e) => {
                if (!active) return;
                active = false;

                const t = e.changedTouches ? e.changedTouches[0] : null;
                if (!t) return;

                const dx = t.clientX - sx;
                const dy = t.clientY - sy;

                if (Math.abs(dx) < 45) return;
                if (Math.abs(dx) <= Math.abs(dy)) return;

                const cur = Number(document.body.getAttribute("data-focus-race") || "1") || 1;
                const next = dx < 0 ? Math.min(TOTAL_RACES, cur + 1) : Math.max(1, cur - 1);
                if (next !== cur) applyRaceFocus(String(next));
            };

            root.addEventListener("touchstart", start, ac ? { passive: true, signal: ac.signal } : { passive: true });
            root.addEventListener("touchmove", move, ac ? { passive: false, signal: ac.signal } : { passive: false });
            root.addEventListener("touchend", end, ac ? { passive: true, signal: ac.signal } : { passive: true });
            root.addEventListener("touchcancel", end, ac ? { passive: true, signal: ac.signal } : { passive: true });
        }

        window.addEventListener("resize", () => {
            applyRaceFocus(isMobileLayout() ? (document.body.getAttribute("data-focus-race") || "1") : "all");
        });

        createRaceTables();
        applyRaceFocus(isMobileLayout() ? "1" : "all");
        initMobileSwipe();
        restoreState();
        applyShareFromURL();
        loadWin5Tabs();
    </script>
</body>

</html>