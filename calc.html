<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>WIN5買い目計算</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: "メイリオ", Meiryo, Hiragino Sans, Hiragino Kaku Gothic ProN, 'ヒラギノ角ゴ ProN W3', 'ヒラギノ角ゴ Pro W3', Helvetica Neue, Helvetica, sans-serif;
            margin: 20px;
            background: #f9fafb;
            color: #333;
            user-select: none !important;
            -webkit-user-select: none !important;
            -ms-user-select: none !important;
        }

        table {
            touch-action: manipulation;
            border-collapse: collapse;
            width: 100%;
        }

        th,
        td {
            touch-action: manipulation;
            border: 1px solid #d9d8ce;
            padding: 4px;
            text-align: center;
            font-size: 18px;
        }

        th {
            background-color: #e0f0ff;
            font-weight: bold;
        }

        button.calc-btn {
            padding: 6px 12px;
            font-size: 20px;
            background-color: #0078d4;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        #result {
            margin-top: 20px;
            font-weight: bold;
            font-size: 20px;
        }

        #combos {
            margin-top: 10px;
            font-size: 20px;
            white-space: normal;
            word-break: keep-all;
            overflow-x: auto;
            display: block;
        }

        .clear-btn {
            padding: 4px 6px;
            font-size: 18px;
            background-color: #edebe5;
            color: #444;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            box-sizing: border-box;
        }

        .custom-select {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            width: fit-content;
            margin: 0 auto;
            position: relative;
        }

        .custom-select.has-name {
            width: 100%;
            margin-left: 0;
            margin-right: 0;
        }

        .selected {
            background-color: white;
            border: 1px solid #888;
            border-radius: 8px;
            padding: 4px 2px;
            text-align: center;
            user-select: none;
            width: 32px;
            height: 32px;
            line-height: 32px;
            font-size: 18px;
            font-weight: bold;
        }

        .custom-select .horse-label {
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            height: 32px;
            padding: 0 4px;
            font-size: 18px !important;
            font-weight: bold;
            color: #555;
            user-select: none;
            white-space: nowrap;
            overflow: visible;
            flex: 1;
        }

        .jockey-label {
            font-size: 14px;
            color: #555;
            text-align: right;
            white-space: nowrap;
            margin-left: auto;
            min-width: 3em;
            pointer-events: none;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .switch {
            position: relative;
            width: 46px;
            height: 24px;
            background: #ccc;
            border-radius: 24px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .switch::after {
            content: "";
            top: 2px;
            left: 2px;
            position: absolute;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: left 0.2s;
        }

        .switch.on {
            background: #2196F3;
        }

        .switch.on::after {
            left: 24px;
        }

        table thead th {
            background: #f4f2ec !important;
        }

        * {
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        }

        .custom-select,
        .custom-select * {
            -webkit-user-select: none;
            user-select: none;
        }

        .selected:focus {
            outline: none;
        }

        .combo-grid {
            display: grid;
            grid-template-columns: 32px repeat(5, max-content);
            column-gap: 0;
            row-gap: 2px;
            padding: 4px 0;
        }

        .combo-row {
            display: contents;
        }

        .combo-check-wrap,
        .combo-cell {
            min-height: 32px;
            display: flex;
            align-items: center;
        }

        .combo-cell {
            white-space: nowrap;
            padding: 0 12px;
            border-radius: 0;
        }

        .combo-check-wrap {
            justify-content: center;
            padding: 0 4px;
            cursor: pointer;
        }

        .combo-check {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .combo-check-visual {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            background-color: #f3f3f3;
            border: 1px solid #d5d5d5;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: #c5c5c5;
        }

        .combo-row.checked .combo-check-wrap,
        .combo-row.checked .combo-cell {
            background-color: #ffe6ea;
        }

        .combo-row.checked .combo-check-visual {
            background-color: #e85b4a;
            border-color: #e85b4a;
            color: #ffffff;
        }

        .top-bar-right {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-bottom: 12px;
        }

        .button-row {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 6px;
            width: 100%;
        }

        .table-wrapper {
            width: 100%;
            overflow-x: auto;
        }

        .custom-select:not(.has-name) .horse-label {
            flex: 0;
            padding: 0 4px;
        }

        .custom-select:not(.has-name) .jockey-label {
            display: none;
        }

        #win5TabSelect {
            padding: 6px 12px;
            font-size: 20px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #fff;
            color: #333;
            box-sizing: border-box;
        }

        #minFav {
            font-size: 20px;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #fff;
            color: #333;
            box-sizing: border-box;
        }
    </style>
</head>

<body>

    <style>
        .menu-container {
            position: relative;
            margin-bottom: 20px;
        }

        .menu-button {
            background: #0078d4;
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            display: inline-block;
        }

        .menu-icon {
            font-size: 28px;
            line-height: 1;
            display: inline-block;
        }

        .menu-list {
            display: none;
            position: absolute;
            top: 45px;
            left: 0;
            background: white;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            min-width: 140px;
            z-index: 999;
        }

        .menu-list a {
            display: block;
            padding: 10px 14px;
            text-decoration: none;
            color: #333;
            border-bottom: 1px solid #eee;
        }

        .menu-list a:hover {
            background: #f0f7ff;
        }

        .menu-list a:last-child {
            border-bottom: none;
        }
    </style>

    <div class="menu-container">
        <div class="menu-button" onclick="toggleMenu()">
            <span class="menu-icon">☰</span>
        </div>
        <div class="menu-list" id="globalMenu">
            <a href="./calc.html">買い目計算</a>
            <a href="./shushi.html">収支計算</a>
        </div>
    </div>

    <script>
        function toggleMenu() {
            const menu = document.getElementById("globalMenu");
            menu.style.display = (menu.style.display === "block") ? "none" : "block";
        }

        document.addEventListener("click", function (e) {
            const menu = document.getElementById("globalMenu");
            const btn = document.querySelector(".menu-button");

            if (!menu.contains(e.target) && !btn.contains(e.target)) {
                menu.style.display = "none";
            }
        });
    </script>

    <div class="top-bar-right">
        <select id="win5TabSelect"></select>
        <button class="calc-btn" onclick="loadWin5Data()">データ取得</button>
        <button class="calc-btn" onclick="clearAllHorseNames()">クリア</button>
    </div>

    <br>

    <div class="toggle-container">
        背景選択
        <div id="modeToggle" class="switch"></div>
    </div>

    <div class="table-wrapper">
        <table id="raceTable">
            <thead>
                <tr>
                    <th>WIN1</th>
                    <th>WIN2</th>
                    <th>WIN3</th>
                    <th>WIN4</th>
                    <th>WIN5</th>
                </tr>
            </thead>
            <tbody id="raceBody"></tbody>
            <tfoot>
                <tr>
                    <td><button class="clear-btn" onclick="clearColumn(1)">クリア</button></td>
                    <td><button class="clear-btn" onclick="clearColumn(2)">クリア</button></td>
                    <td><button class="clear-btn" onclick="clearColumn(3)">クリア</button></td>
                    <td><button class="clear-btn" onclick="clearColumn(4)">クリア</button></td>
                    <td><button class="clear-btn" onclick="clearColumn(5)">クリア</button></td>
                </tr>
            </tfoot>
        </table>
    </div>

    <div style="margin-top:18px; font-size: 20px;">
        本命
        <select id="minFav" style="font-size: 20px;">
            <option value="1" selected>1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
        </select> 勝
    </div>

    <div class="button-row">
        <button class="calc-btn" onclick="calc()">計算する</button>
    </div>

    <div id="result"></div>
    <div id="combos"></div>

    <script>
        const TOTAL_RACES = 5;
        const HORSE_MAX = 18;
        const MARKS = ["", "✔", "◎"];
        const CIRCLES = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮', '⑯', '⑰', '⑱'];
        let backgroundMode = false;
        const modeBtn = document.getElementById("modeToggle");

        function updateSwitch() {
            backgroundMode ? modeBtn.classList.add("on") : modeBtn.classList.remove("on");
        }
        modeBtn.addEventListener("click", () => {
            backgroundMode = !backgroundMode;
            updateSwitch();
        });
        updateSwitch();

        function toCircleNumber(num) {
            return CIRCLES[num - 1] || String(num);
        }

        function createCustomSelect(raceNum, horseNum) {
            const wrapper = document.createElement("div");
            wrapper.className = "custom-select";
            wrapper.dataset.race = raceNum;
            wrapper.dataset.horse = horseNum;

            const selected = document.createElement("div");
            selected.className = "selected";
            selected.textContent = "";
            selected.dataset.bg = "none";

            selected.addEventListener("click", (e) => {
                if (backgroundMode) {
                    const palette = document.createElement("div");
                    palette.style.position = "absolute";
                    palette.style.zIndex = 9999;
                    palette.style.display = "flex";
                    palette.style.gap = "10px";
                    palette.style.background = "#fff";
                    palette.style.border = "1px solid #999";
                    palette.style.padding = "10px";
                    palette.style.borderRadius = "10px";
                    palette.style.boxShadow = "0 4px 10px rgba(0,0,0,0.2)";

                    const colors = ["#b3d1ff", "#fff3b3", "#b3ffb3", "#e0b3ff", "#b3fff0", "#c8ad9d"];
                    colors.forEach(c => {
                        const btn = document.createElement("div");
                        btn.style.width = "36px";
                        btn.style.height = "36px";
                        btn.style.backgroundColor = c;
                        btn.style.border = "1px solid #777";
                        btn.style.borderRadius = "6px";
                        btn.style.cursor = "pointer";
                        btn.addEventListener("click", () => {
                            selected.dataset.bg = c;
                            selected.style.backgroundColor = c;
                            palette.remove();
                            saveState();
                        });
                        palette.appendChild(btn);
                    });

                    const noneBtn = document.createElement("div");
                    noneBtn.style.width = "36px";
                    noneBtn.style.height = "36px";
                    noneBtn.style.background = "#fff";
                    noneBtn.style.border = "1px solid #777";
                    noneBtn.style.borderRadius = "6px";
                    noneBtn.style.cursor = "pointer";
                    noneBtn.addEventListener("click", () => {
                        selected.dataset.bg = "none";
                        selected.style.backgroundColor = "";
                        palette.remove();
                        saveState();
                    });
                    palette.appendChild(noneBtn);

                    document.body.appendChild(palette);
                    const rect = palette.getBoundingClientRect();
                    const pw = rect.width;
                    const ph = rect.height;
                    const vw = window.innerWidth;
                    const vh = window.innerHeight;
                    let left = e.pageX;
                    let top = e.pageY;
                    if (left + pw > vw - 10) left = vw - pw - 10;
                    if (top + ph > vh - 10) top = vh - ph - 10;
                    palette.style.left = left + "px";
                    palette.style.top = top + "px";

                    const closePalette = (ev) => {
                        if (!palette.contains(ev.target)) {
                            palette.remove();
                            document.removeEventListener("click", closePalette);
                        }
                    };
                    setTimeout(() => document.addEventListener("click", closePalette), 0);
                } else {
                    const cur = MARKS.indexOf(selected.textContent);
                    selected.textContent = MARKS[(cur + 1) % MARKS.length];
                    const mark = selected.textContent;
                    selected.style.opacity = "1";
                    applyMarkBackground(wrapper, mark !== "");
                    saveState();
                }
            });

            const label = document.createElement("span");
            label.className = "horse-label";
            label.textContent = toCircleNumber(horseNum);

            const jockeyLabel = document.createElement("span");
            jockeyLabel.className = "jockey-label";
            jockeyLabel.textContent = "";

            wrapper.appendChild(selected);
            wrapper.appendChild(label);
            wrapper.appendChild(jockeyLabel);

            return wrapper;
        }

        function createTable() {
            const tbody = document.getElementById('raceBody');
            for (let i = 1; i <= HORSE_MAX; i++) {
                const tr = document.createElement('tr');
                for (let r = 1; r <= TOTAL_RACES; r++) {
                    const td = document.createElement('td');
                    td.appendChild(createCustomSelect(r, i));
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            }
        }

        let lastState = '';
        function saveState() {
            const state = { races: {}, minFav: document.getElementById('minFav').value, raceInfo: window.raceInfo || ["", "", "", "", ""] };

            for (let r = 1; r <= TOTAL_RACES; r++) {
                state.races[`r${r}`] = {};
                document.querySelectorAll(`.custom-select[data-race="${r}"]`).forEach(sel => {
                    const d = sel.querySelector('.selected');
                    const label = sel.querySelector('.horse-label');
                    const jLabel = sel.querySelector('.jockey-label');
                    const horseNum = Number(sel.dataset.horse);
                    const circle = toCircleNumber(horseNum);

                    let name = null;
                    let jockey = null;

                    if (label) {
                        const txt = label.textContent || "";
                        if (txt) {
                            if (txt.startsWith(circle)) {
                                name = txt.slice(circle.length).trim();
                            } else {
                                name = txt.trim();
                            }
                        }
                    }

                    if (jLabel) {
                        const jt = (jLabel.textContent || "").trim();
                        if (jt) {
                            jockey = jt;
                        }
                    }

                    state.races[`r${r}`][sel.dataset.horse] = {
                        mark: d.textContent,
                        bg: d.dataset.bg || "none",
                        name: name,
                        jockey: jockey
                    };
                });
            }

            const str = JSON.stringify(state);
            if (str !== lastState) {
                localStorage.setItem('win5_state_v7', str);
                lastState = str;
            }
        }

        function restoreState() {
            const data = localStorage.getItem('win5_state_v7');
            if (!data) return;
            try {
                const state = JSON.parse(data);
                if (state.raceInfo) {
                    window.raceInfo = state.raceInfo;
                    updateRaceHeaders(state.raceInfo);
                }
                if (state.minFav) {
                    document.getElementById('minFav').value = state.minFav;
                }

                for (let r = 1; r <= TOTAL_RACES; r++) {
                    const race = state.races[`r${r}`];
                    if (!race) continue;

                    document.querySelectorAll(`.custom-select[data-race="${r}"]`).forEach(sel => {
                        const val = race[sel.dataset.horse];
                        if (!val) return;

                        const d = sel.querySelector('.selected');
                        const label = sel.querySelector('.horse-label');
                        const jLabel = sel.querySelector('.jockey-label');
                        const horseNum = Number(sel.dataset.horse);
                        const circle = toCircleNumber(horseNum);

                        d.textContent = val.mark || "";
                        d.style.opacity = "1";
                        applyMarkBackground(sel, !!val.mark);
                        d.dataset.bg = val.bg || "none";
                        d.style.backgroundColor =
                            (val.bg && val.bg !== "none") ? val.bg : "";

                        if (!label) return;

                        const n = val.name;
                        const j = (val.jockey || "").trim();

                        if (n === null) {
                            label.textContent = "";
                            if (jLabel) jLabel.textContent = "";
                            sel.classList.remove('has-name');
                            sel.style.visibility = 'hidden';

                            d.textContent = "";
                            d.dataset.bg = "none";
                            d.style.backgroundColor = "";
                        } else if (typeof n === "string" && n.length > 0) {
                            label.textContent = circle + " " + n;
                            if (jLabel) jLabel.textContent = j;
                            sel.classList.add('has-name');
                            sel.style.visibility = 'visible';
                        } else {
                            label.textContent = circle;
                            if (jLabel) jLabel.textContent = j;
                            sel.classList.remove('has-name');
                            sel.style.visibility = 'visible';
                        }
                    });
                }
            } catch (e) { }
        }

        function clearColumn(colNum) {
            document.querySelectorAll(`.custom-select[data-race="${colNum}"]`).forEach(sel => {
                const selected = sel.querySelector(".selected");

                selected.textContent = "";
                selected.dataset.bg = "none";
                selected.style.backgroundColor = "white";

                applyMarkBackground(sel, false);
            });
            saveState();
        }

        function clearAllHorseNames() {
            document.querySelectorAll('.custom-select').forEach(sel => {
                const label = sel.querySelector('.horse-label');
                const jockeyLabel = sel.querySelector('.jockey-label');
                if (!label) return;

                const horseNum = Number(sel.dataset.horse);
                const circle = toCircleNumber(horseNum);

                label.textContent = circle;

                if (jockeyLabel) {
                    jockeyLabel.textContent = "";
                }

                sel.classList.remove('has-name');
                sel.style.visibility = 'visible';
            });

            window.raceInfo = ["", "", "", "", ""];
            updateRaceHeaders(window.raceInfo);

            saveState();
        }

        function getRaceData(r) {
            const favs = [], himo = [], colorMap = {};
            document.querySelectorAll(`.custom-select[data-race="${r}"]`).forEach(sel => {
                const v = sel.querySelector('.selected').textContent;
                const bg = sel.querySelector('.selected').dataset.bg;
                const num = Number(sel.dataset.horse);
                colorMap[num] = bg;
                if (v === "◎") favs.push(num);
                if (v === "✔") himo.push(num);
            });
            const all = [...new Set([...favs, ...himo])];
            return { fav: favs, horse: all, colorMap };
        }

        function combinations(arr, k) {
            const res = [];
            (function h(s, c) {
                if (c.length === k) {
                    res.push([...c]);
                    return;
                }
                for (let i = s; i < arr.length; i++) {
                    c.push(arr[i]);
                    h(i + 1, c);
                    c.pop();
                }
            })(0, []);
            return res;
        }

        function setEq(a, b) {
            if (a.size !== b.size) return false;
            for (const x of a) if (!b.has(x)) return false;
            return true;
        }

        function setUnion(a, b) {
            const s = new Set(a);
            for (const x of b) s.add(x);
            return s;
        }

        function setInterEmpty(a, b) {
            for (const x of a) if (b.has(x)) return false;
            return true;
        }

        function attachComboEvents() {
            document.querySelectorAll('#combos .combo-check').forEach(chk => {
                chk.addEventListener('change', () => {
                    const row = chk.closest('.combo-row');
                    if (!row) return;
                    if (chk.checked) {
                        row.classList.add('checked');
                    } else {
                        row.classList.remove('checked');
                    }
                });
            });
        }

        function calc() {
            const t0 = performance.now();

            const races = [], favs = [], colorArray = [];
            for (let i = 1; i <= TOTAL_RACES; i++) {
                const d = getRaceData(i);
                races.push(d.horse);
                favs.push(d.fav);
                const colors = new Array(HORSE_MAX + 1);
                for (let h = 1; h <= HORSE_MAX; h++) colors[h] = d.colorMap[h] || "none";
                colorArray.push(colors);
            }

            const favMaskList = favs.map(a => a.map(x => 1 << (x - 1)));
            const nonFavMaskList = races.map((a, idx) => {
                const favSet = new Set(favs[idx]);
                return a.filter(x => !favSet.has(x)).map(x => 1 << (x - 1));
            });

            const colorIdTable = Array.from(
                { length: TOTAL_RACES },
                () => new Int16Array(HORSE_MAX).fill(-1)
            );
            const colorIdMap = new Map();
            let nextColorId = 0;
            for (let i = 0; i < TOTAL_RACES; i++) {
                const usedHorses = races[i];
                for (let idx = 0; idx < usedHorses.length; idx++) {
                    const h = usedHorses[idx];
                    const c = colorArray[i][h];
                    if (c && c !== "none") {
                        let id = colorIdMap.get(c);
                        if (id === undefined) {
                            id = nextColorId++;
                            colorIdMap.set(c, id);
                        }
                        colorIdTable[i][h - 1] = id;
                    }
                }
            }

            const colorIdOf = (raceIdx, singleBitMask) => {
                const idx = Math.log2(singleBitMask) | 0;
                return colorIdTable[raceIdx][idx];
            };

            const masksCache = {};
            function getMasks(k) {
                if (!masksCache[k]) masksCache[k] = combinations([...Array(TOTAL_RACES).keys()], k);
                return masksCache[k];
            }

            function countCombosDFS(candidates) {
                const n = candidates.length;

                const order = Array.from({ length: n }, (_, i) => i)
                    .sort((a, b) => candidates[a].length - candidates[b].length);

                const revOrder = new Int8Array(n);
                for (let i = 0; i < n; i++) revOrder[order[i]] = i;

                const candColorIds = new Array(n);
                for (let r = 0; r < n; r++) {
                    const arr = candidates[r];
                    const ids = new Int16Array(arr.length);
                    for (let i = 0; i < arr.length; i++) {
                        const bit = arr[i];
                        const idx = Math.log2(bit) | 0;
                        ids[i] = colorIdTable[r][idx];
                    }
                    candColorIds[r] = ids;
                }

                let count = 0;
                const blocks = [];
                const path = new Int32Array(n);

                const dfs = (depth, usedColorMask) => {
                    if (depth === n) {
                        count++;
                        const combo = new Array(n);
                        for (let i = 0; i < n; i++) combo[i] = path[revOrder[i]];
                        blocks.push(combo);
                        return;
                    }

                    const raceIdx = order[depth];
                    const arr = candidates[raceIdx];
                    const colorIds = candColorIds[raceIdx];

                    for (let k = 0; k < arr.length; k++) {
                        const m = arr[k];
                        const colorId = colorIds[k];

                        if (colorId >= 0 && (usedColorMask & (1 << colorId))) continue;

                        path[depth] = m;
                        const nextMask = (colorId >= 0) ? (usedColorMask | (1 << colorId)) : usedColorMask;
                        dfs(depth + 1, nextMask);
                    }
                };

                dfs(0, 0);
                return { count, blocks };
            }

            const minFav = Number(document.getElementById('minFav').value);
            let total = 0;
            const comboList = [];

            const k = minFav;
            const masks = getMasks(k);
            let count = 0;
            let blocks = [];

            for (let m = 0; m < masks.length; m++) {
                const maskArr = masks[m];
                const maskSet = new Set(maskArr);
                const candidates = new Array(TOTAL_RACES);
                let valid = true;

                for (let i = 0; i < TOTAL_RACES; i++) {
                    candidates[i] = maskSet.has(i) ? favMaskList[i] : nonFavMaskList[i];
                    if (candidates[i].length === 0) { valid = false; break; }
                }
                if (!valid) continue;

                const res = countCombosDFS(candidates);
                count += res.count;

                for (let i = 0; i < res.blocks.length; i++) {
                    blocks.push(res.blocks[i]);
                }
            }

            const displayBlocks = fullyMergeBlocksStableBit(blocks);
            comboList.push('<div class="combo-grid">');
            for (const b of displayBlocks) comboList.push(blockToLineBit(b));
            comboList.push('</div>');

            total = count;

            const t1 = performance.now();
            const elapsedMs = t1 - t0;
            console.log(`計算速度: ${elapsedMs.toFixed()} ms`);

            document.getElementById('result').innerHTML =
                `組合せ：<span style="color:#0078d4;">${total.toLocaleString()}</span> 通り`;
            const fragment = document.createDocumentFragment();
            const container = document.createElement('div');
            container.innerHTML = comboList.join('');
            fragment.appendChild(container);
            document.getElementById('combos').replaceChildren(fragment);
            attachComboEvents();
            saveState();
        }

        function fullyMergeBlocksStableBit(blocks) {
            const n = TOTAL_RACES | 0;
            if (blocks.length <= 1) return blocks;

            let changed = true;
            while (changed) {
                changed = false;

                for (let d = 0; d < n; d++) {
                    const len = blocks.length;
                    if (len <= 1) break;

                    const map = new Map();
                    for (let i = 0; i < len; i++) {
                        const b = blocks[i];
                        let key = "";
                        for (let k = 0; k < n; k++) {
                            if (k === d) continue;
                            key += b[k] + ",";
                        }
                        let arr = map.get(key);
                        if (!arr) {
                            arr = [];
                            map.set(key, arr);
                        }
                        arr.push(i);
                    }

                    const used = new Uint8Array(len);
                    const next = [];

                    for (let i = 0; i < len; i++) {
                        if (used[i]) continue;

                        const baseRow = blocks[i];
                        let key = "";
                        for (let k = 0; k < n; k++) {
                            if (k === d) continue;
                            key += baseRow[k] + ",";
                        }
                        const group = map.get(key);

                        if (!group || group.length === 1) {
                            next.push(baseRow);
                            used[i] = 1;
                            continue;
                        }

                        let mergedRow = baseRow.slice();
                        used[i] = 1;

                        for (let gi = 0; gi < group.length; gi++) {
                            const j = group[gi];
                            if (j === i || used[j]) continue;

                            const row = blocks[j];
                            if ((mergedRow[d] & row[d]) === 0) {
                                mergedRow[d] |= row[d];
                                used[j] = 1;
                                changed = true;
                            }
                        }

                        next.push(mergedRow);
                    }

                    blocks = next;
                }
            }
            return blocks;
        }

        function blockToLineBit(block) {
            const parts = block.map(mask => {
                const nums = [];
                for (let i = 0; i < HORSE_MAX; i++) {
                    if (mask & (1 << i)) nums.push(toCircleNumber(i + 1));
                }
                return nums.join('');
            });
            const cells = parts.map(p => `<span class="combo-cell">${p}</span>`).join('');
            return (
                '<div class="combo-row">' +
                '<label class="combo-check-wrap">' +
                '<input type="checkbox" class="combo-check">' +
                '<span class="combo-check-visual">✓</span>' +
                '</label>' +
                cells +
                '</div>'
            );
        }

        const WIN5_API = "https://win5-proxy.cooopew.workers.dev/";

        async function fetchWin5(tabIndex) {
            let api = WIN5_API;
            if (typeof tabIndex === "number" && !Number.isNaN(tabIndex)) {
                api += `?tab=${tabIndex}`;
            }

            const res = await fetch(api);
            const json = await res.json();
            return json;
        }

        function populateWin5Tabs(tabs, activeTabIndex) {
            const select = document.getElementById('win5TabSelect');
            if (!select || !Array.isArray(tabs) || tabs.length === 0) return;

            select.innerHTML = "";

            tabs.forEach((t, i) => {
                const opt = document.createElement('option');
                opt.value = String(i);
                opt.textContent = t.label || `タブ${i + 1}`;
                if (i === activeTabIndex) {
                    opt.selected = true;
                }
                select.appendChild(opt);
            });
        }

        function applyWin5Data(json) {

            window.raceInfo = json.raceInfo || [];

            updateRaceHeaders(window.raceInfo);

            const races = json.races || [];

            for (let r = 0; r < TOTAL_RACES; r++) {
                const horses = (races[r] && races[r].horses) ? races[r].horses : [];
                const jockeys = (races[r] && races[r].jockeys) ? races[r].jockeys : [];

                for (let i = 1; i <= HORSE_MAX; i++) {
                    const raceNum = r + 1;
                    const horseNum = i;
                    const name = horses[i - 1] || "";
                    const jockey = jockeys[i - 1] || "";

                    const sel = document.querySelector(
                        `.custom-select[data-race="${raceNum}"][data-horse="${horseNum}"]`
                    );
                    if (!sel) continue;

                    const label = sel.querySelector(".horse-label");
                    const selected = sel.querySelector(".selected");
                    const jockeyLabel = sel.querySelector(".jockey-label");
                    if (!label || !selected || !jockeyLabel) continue;

                    if (name) {
                        const circle = toCircleNumber(horseNum);
                        label.textContent = circle + " " + name;
                        jockeyLabel.textContent = jockey || "";
                        sel.classList.add("has-name");
                        sel.style.visibility = "visible";
                    } else {
                        label.textContent = "";
                        jockeyLabel.textContent = "";
                        sel.classList.remove("has-name");
                        sel.style.visibility = "hidden";

                        selected.textContent = "";
                        selected.dataset.bg = "none";
                        selected.style.backgroundColor = "";
                    }
                }
            }

            saveState();
        }

        function updateRaceHeaders(raceInfo) {
            const thRow = document.querySelector("#raceTable thead tr");
            thRow.innerHTML = "";

            for (let i = 0; i < 5; i++) {
                const th = document.createElement("th");
                const label = `WIN${i + 1}` + (raceInfo[i] ? ` ${raceInfo[i]}` : "");
                th.textContent = label;
                thRow.appendChild(th);
            }
        }

        async function loadWin5Data() {
            const idx = document.getElementById("win5TabSelect").value;
            const api = "https://win5-proxy.cooopew.workers.dev/?tab=" + idx;

            const res = await fetch(api);
            const json = await res.json();

            if (!json.ok) return;

            applyWin5Data(json);
        }

        async function loadWin5Tabs() {
            const api = "https://win5-proxy.cooopew.workers.dev/";

            const res = await fetch(api);
            const json = await res.json();

            if (!json.ok) return;

            const tabs = json.tabs || [];
            const current = json.activeTab ?? 0;

            const select = document.getElementById("win5TabSelect");
            if (!select) return;

            select.innerHTML = "";

            tabs.forEach((t, i) => {
                const op = document.createElement("option");
                op.value = i;
                op.textContent = t.label;
                if (i === current) op.selected = true;
                select.appendChild(op);
            });
        }

        function renderHorseLabel(label, horseNum, nameWithOrWithoutJockey) {
            const circle = toCircleNumber(horseNum);

            let horseName = nameWithOrWithoutJockey || "";
            let jockeyName = "";

            const start = horseName.lastIndexOf("（");
            const end = horseName.endsWith("）") ? horseName.length - 1 : -1;

            if (start !== -1 && end > start) {
                jockeyName = horseName.slice(start + 1, end).trim();
                horseName = horseName.slice(0, start).trim();
            } else {
                horseName = horseName.trim();
            }

            label.textContent = "";
            label.append(document.createTextNode(circle + (horseName ? " " + horseName : "")));

            if (jockeyName) {
                const span = document.createElement("span");
                span.className = "jockey-name";
                span.textContent = `（${jockeyName}）`;
                label.appendChild(span);
            }
        }

        function setHorseAndJockey(label, horseNum, horseName, jockeyName) {
            const textForState = jockeyName
                ? `${horseName}（${jockeyName}）`
                : horseName;
            renderHorseLabel(label, horseNum, textForState);
        }

        function applyMarkBackground(sel, hasMark) {
            const td = sel.parentElement;
            if (!td) return;

            td.style.backgroundColor = hasMark ? "#ffc8c8" : "";
        }

        createTable();
        restoreState();
        loadWin5Tabs();
    </script>

</body>

</html>