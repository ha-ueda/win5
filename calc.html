<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>WIN5 買い目計算</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: "メイリオ", Meiryo, Hiragino Sans, Hiragino Kaku Gothic ProN, 'ヒラギノ角ゴ ProN W3', 'ヒラギノ角ゴ Pro W3', Helvetica Neue, Helvetica, sans-serif;
            margin: 15px;
            background: #f9fafb;
            color: #333;
            user-select: none !important;
            -webkit-user-select: none !important;
            -ms-user-select: none !important;
        }

        table {
            touch-action: manipulation;
            border-collapse: collapse;
            width: 100%;
            background: #eaeaea;
        }

        th,
        td {
            touch-action: manipulation;
            border: 1px solid #d9d8ce;
            padding: 4px;
            text-align: center;
            font-size: 18px;
        }

        th {
            background-color: #e0f0ff;
            font-weight: bold;
        }

        tfoot td {
            padding: 0;
        }

        button.calc-btn {
            padding: 6px 12px;
            font-size: 22px;
            background-color: #0078d4;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        #result {
            margin-top: 20px;
            font-weight: bold;
            font-size: 20px;
        }

        #combos {
            margin-top: 10px;
            font-size: 22px;
            white-space: normal;
            word-break: keep-all;
            overflow-x: auto;
            display: block;
            padding-bottom: calc(300px + env(safe-area-inset-bottom));
        }

        #combos:empty {
            padding-bottom: 0;
        }

        #combos,
        .table-wrapper {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        #combos::-webkit-scrollbar,
        .table-wrapper::-webkit-scrollbar {
            display: none;
            height: 0;
        }

        .clear-btn {
            padding: 4px 4px;
            font-size: 18px;
            background-color: #f4f2ec;
            color: #444;
            border: none;
            cursor: pointer;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            font-weight: bold;
        }

        .custom-select {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            width: fit-content;
            margin: 0 auto;
            position: relative;
        }

        .custom-select.has-name {
            width: 100%;
            margin-left: 0;
            margin-right: 0;
        }

        .selected {
            background: #eaeaea;
            border: 1px solid #888;
            border-radius: 8px;
            text-align: center;
            user-select: none;
            width: 32px;
            height: 32px;
            line-height: 32px;
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }

        .selected.is-marked {
            background-color: #ec5754 !important;
            color: #fff !important;
            border-color: #ec5754 !important;
        }

        .custom-select .horse-label {
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            height: 32px;
            font-size: 18px !important;
            font-weight: bold;
            color: #555;
            user-select: none;
            white-space: nowrap;
            overflow: visible;
            flex: 1;
        }

        .horse-num {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            padding: 0 6px;
            border-radius: 8px;
            line-height: 32px;
        }

        .horse-name {
            margin-left: 3px;
            font-size: 16px;
        }

        .jockey-label {
            width: 100%;
            display: block;
            font-size: 13px;
            color: #555;
            text-align: right;
            white-space: nowrap;
            min-width: 3em;
            pointer-events: none;
            align-self: flex-end;
            margin-bottom: 2px;
            line-height: 1;
        }

        .odds-label {
            font-feature-settings: "tnum" 1;
            font-variant-numeric: tabular-nums;
            width: 100%;
            display: block;
            text-align: right;
            white-space: pre;
            font-size: 13px;
            color: #333;
            align-self: flex-end;
            margin-bottom: 2px;
            line-height: 1;
            pointer-events: none;
            min-height: 13px;
        }

        .meta-labels {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
            margin-left: auto;
            min-width: 4.5em;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .switch {
            position: relative;
            width: 46px;
            height: 24px;
            background: #ccc;
            border-radius: 24px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .switch::after {
            content: "";
            top: 2px;
            left: 2px;
            position: absolute;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: left 0.2s;
        }

        .switch.on {
            background: #2196F3;
        }

        .switch.on::after {
            left: 24px;
        }

        table thead th {
            background: #f4f2ec !important;
        }

        * {
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        }

        .custom-select,
        .custom-select * {
            -webkit-user-select: none;
            user-select: none;
        }

        .selected:focus {
            outline: none;
        }

        .combo-grid {
            display: grid;
            grid-template-columns: 32px repeat(5, max-content);
            column-gap: 0;
            row-gap: 2px;
            padding: 4px 0;
        }

        .combo-row {
            display: contents;
        }

        .combo-check-wrap,
        .combo-cell {
            min-height: 32px;
            display: flex;
            align-items: center;
        }

        .combo-cell {
            white-space: nowrap;
            padding: 0 12px;
            border-radius: 0;
        }

        .combo-check-wrap {
            justify-content: center;
            padding: 0 4px;
            cursor: pointer;
        }

        .combo-check {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .combo-check-visual {
            width: 24px;
            height: 24px;
            border-radius: 8px;
            background-color: #f3f3f3;
            border: 1px solid #d5d5d5;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            color: #c5c5c5;
        }

        .combo-row.checked .combo-check-wrap,
        .combo-row.checked .combo-cell {
            background-color: #fff0f0;
        }

        .combo-row.checked .combo-check-visual {
            background-color: #ec5754;
            border-color: #ec5754;
            color: #ffffff;
        }

        .top-bar-right {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-bottom: 12px;
        }

        .button-row {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 18px;
            width: 100%;
        }

        .table-wrapper {
            width: 100%;
            overflow-x: auto;
        }

        .custom-select:not(.has-name) {
            width: 100%;
            justify-content: center;
        }

        .custom-select:not(.has-name) .horse-label {
            flex: 0 0 auto;
            padding: 0 4px;
            justify-content: center;
        }

        .custom-select:not(.has-name) .meta-labels {
            display: none;
        }

        .custom-select:not(.has-name) .jockey-label {
            display: none;
        }

        .custom-select:not(.has-name) .horse-name {
            display: none;
        }

        #win5TabSelect {
            padding: 6px 12px;
            font-size: 22px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #fff;
            color: #333;
            box-sizing: border-box;
        }

        #minFav {
            font-size: 20px;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #fff;
            color: #333;
            box-sizing: border-box;
        }

        .race-focus {
            display: none;
        }

        @media (max-width: 640px) {
            body {
                margin: 10px;
            }

            .top-bar-right {
                flex-wrap: wrap;
                justify-content: flex-start;
                gap: 8px;
                margin-bottom: 10px;
            }

            .top-bar-right>* {
                flex: 1 1 auto;
                min-width: 0;
            }

            #win5TabSelect {
                width: 100%;
                font-size: 18px;
                padding: 10px 10px;
            }

            button.calc-btn {
                width: 100%;
                font-size: 18px;
                padding: 10px 10px;
                border-radius: 10px;
            }

            .toggle-container {
                font-size: 18px;
                gap: 10px;
                margin-bottom: 8px;
            }

            .race-focus {
                display: none;
            }

            @media (max-width: 640px) {
                .race-focus {
                    display: grid;
                    grid-template-columns: repeat(3, minmax(0, 1fr));
                    gap: 6px;
                    margin: 8px 0 10px;
                    background: rgba(249, 250, 251, 0.95);
                    padding: 8px 0;
                    backdrop-filter: blur(6px);
                }

                .race-focus button {
                    width: 100%;
                    min-width: 0;
                    min-height: 44px;
                    padding: 10px 6px;
                    font-size: 16px;
                    border-radius: 10px;
                    border: 1px solid #cfd6dd;
                    background: #fff;
                    color: #333;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    line-height: 1;
                }

                .race-focus button.on {
                    background: #0078d4;
                    color: #fff;
                    border-color: #0078d4;
                    font-weight: bold;
                }
            }

            @media (max-width: 640px) {

                body[data-focus-race="1"] #raceTable th:not(:nth-child(1)),
                body[data-focus-race="1"] #raceTable tbody td:not(:nth-child(1)),
                body[data-focus-race="1"] #raceTable tfoot td:not(:nth-child(1)) {
                    display: none;
                }

                body[data-focus-race="2"] #raceTable th:not(:nth-child(2)),
                body[data-focus-race="2"] #raceTable tbody td:not(:nth-child(2)),
                body[data-focus-race="2"] #raceTable tfoot td:not(:nth-child(2)) {
                    display: none;
                }

                body[data-focus-race="3"] #raceTable th:not(:nth-child(3)),
                body[data-focus-race="3"] #raceTable tbody td:not(:nth-child(3)),
                body[data-focus-race="3"] #raceTable tfoot td:not(:nth-child(3)) {
                    display: none;
                }

                body[data-focus-race="4"] #raceTable th:not(:nth-child(4)),
                body[data-focus-race="4"] #raceTable tbody td:not(:nth-child(4)),
                body[data-focus-race="4"] #raceTable tfoot td:not(:nth-child(4)) {
                    display: none;
                }

                body[data-focus-race="5"] #raceTable th:not(:nth-child(5)),
                body[data-focus-race="5"] #raceTable tbody td:not(:nth-child(5)),
                body[data-focus-race="5"] #raceTable tfoot td:not(:nth-child(5)) {
                    display: none;
                }
            }

        }

        /* ===== 印共有モーダル ===== */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20000;
            padding: 14px;
        }

        .modal-card {
            width: min(720px, 100%);
            background: #fff;
            border-radius: 14px;
            border: 1px solid #d7d7d7;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
            padding: 14px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .modal-help {
            font-size: 13px;
            color: #555;
            margin-top: 8px;
            line-height: 1.35;
            user-select: text !important;
            -webkit-user-select: text !important;
        }

        .modal-textarea {
            width: 100%;
            min-height: 120px;
            font-size: 13px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-sizing: border-box;
            resize: vertical;
            user-select: text !important;
            -webkit-user-select: text !important;
        }

        .modal-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .modal-actions .calc-btn {
            font-size: 18px;
            padding: 8px 12px;
        }

        @media (hover: none) and (pointer: coarse) {
            .modal-textarea {
                font-size: 16px;
            }
        }
    </style>
</head>

<body>

    <style>
        .menu-container {
            position: relative;
            margin-bottom: 20px;
        }

        .menu-button {
            background: #0078d4;
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            display: inline-block;
        }

        .menu-icon {
            font-size: 28px;
            line-height: 1;
            display: inline-block;
        }

        .menu-list {
            display: none;
            position: absolute;
            top: 45px;
            left: 0;
            background: white;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            min-width: 140px;
            z-index: 999;
        }

        .menu-list a {
            display: block;
            padding: 10px 14px;
            text-decoration: none;
            color: #333;
            border-bottom: 1px solid #eee;
        }

        .menu-list a:hover {
            background: #f0f7ff;
        }

        .menu-list a:last-child {
            border-bottom: none;
        }
    </style>

    <div class="menu-container">
        <div class="menu-button" onclick="toggleMenu()">
            <span class="menu-icon">☰</span>
        </div>
        <div class="menu-list" id="globalMenu">
            <a href="./calc.html">買い目計算</a>
            <a href="./shushi.html">収支計算</a>
        </div>
    </div>

    <script>
        function toggleMenu() {
            const menu = document.getElementById("globalMenu");
            menu.style.display = (menu.style.display === "block") ? "none" : "block";
        }

        document.addEventListener("click", function (e) {
            const menu = document.getElementById("globalMenu");
            const btn = document.querySelector(".menu-button");

            if (!menu.contains(e.target) && !btn.contains(e.target)) {
                menu.style.display = "none";
            }
        });
    </script>

    <div class="top-bar-right">
        <select id="win5TabSelect"></select>
        <button class="calc-btn" onclick="loadWin5Data()">データ取得</button>
        <button class="calc-btn" onclick="clearAllHorseNames()">クリア</button>
        <button class="calc-btn" onclick="openShare()">共有</button>
    </div>

    <br>

    <div class="toggle-container">
        背景選択
        <div id="modeToggle" class="switch"></div>
    </div>

    <div id="raceFocusBar" class="race-focus" aria-label="表示レース切替"></div>

    <div class="table-wrapper">
        <table id="raceTable">
            <thead>
                <tr>
                    <th>WIN1</th>
                    <th>WIN2</th>
                    <th>WIN3</th>
                    <th>WIN4</th>
                    <th>WIN5</th>
                </tr>
            </thead>
            <tbody id="raceBody"></tbody>
            <tfoot>
                <tr>
                    <td><button class="clear-btn" onclick="clearColumn(1)">クリア</button></td>
                    <td><button class="clear-btn" onclick="clearColumn(2)">クリア</button></td>
                    <td><button class="clear-btn" onclick="clearColumn(3)">クリア</button></td>
                    <td><button class="clear-btn" onclick="clearColumn(4)">クリア</button></td>
                    <td><button class="clear-btn" onclick="clearColumn(5)">クリア</button></td>
                </tr>
            </tfoot>
        </table>
    </div>

    <div style="margin-top:18px; font-size: 20px;">
        本命
        <select id="minFav" style="font-size: 20px;">
            <option value="1" selected>1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
        </select> 勝
    </div>

    <div class="button-row">
        <button class="calc-btn" onclick="calc()">計算する</button>
    </div>

    <div id="result"></div>
    <div id="combos"></div>
    <div id="shareModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-label="印共有">
        <div class="modal-card" onclick="event.stopPropagation()">
            <div class="modal-title">印を共有</div>
            <textarea id="shareText" class="modal-textarea" spellcheck="false"></textarea>
            <div class="modal-actions">
                <button class="calc-btn" onclick="copyShareText()">コピー</button>
                <button class="calc-btn" onclick="importShareText()">読み込み</button>
                <button class="calc-btn" onclick="closeShare()">閉じる</button>
            </div>
            <div class="modal-help">
                ・コピーしたURLを相手に送ってください。<br>
                ・受け取った側はURLを読み込みで反映できます。<br>
                ・馬名/騎手/オッズは共有しません。
            </div>
        </div>
    </div>

    <script>
        const TOTAL_RACES = 5;
        const HORSE_MAX = 18;
        const MARKS = ["", "✓", "◎"];
        const CIRCLES = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮', '⑯', '⑰', '⑱'];
        let backgroundMode = false;
        const modeBtn = document.getElementById("modeToggle");

        function updateSwitch() {
            backgroundMode ? modeBtn.classList.add("on") : modeBtn.classList.remove("on");
        }
        modeBtn.addEventListener("click", () => {
            backgroundMode = !backgroundMode;
            updateSwitch();
        });
        updateSwitch();

        function toCircleNumber(num) {
            return CIRCLES[num - 1] || String(num);
        }

        function updateOddsLabel(el, ninki, odds) {
            if (!el) return;

            const oRaw = (odds ?? "").toString().trim();
            const nRaw = (ninki ?? "").toString().trim();

            const formatOddsFixed = (s) => {
                const t = (s ?? "").toString().trim();
                if (!t) return "";
                if (/^\d{1,3}(?:\.\d)?$/.test(t)) return t.padStart(5, " ");
                return t;
            };

            const o = formatOddsFixed(oRaw);

            let nCircle = "";
            if (nRaw && nRaw !== "**") {
                const nn = Number(nRaw);
                if (Number.isFinite(nn) && nn >= 1 && nn <= 18) nCircle = toCircleNumber(nn);
                else nCircle = nRaw;
            }

            if (o && nCircle) el.textContent = `${o} ${nCircle}`;
            else if (o) el.textContent = o;
            else if (nCircle) el.textContent = nCircle;
            else el.textContent = "";
        }

        function createCustomSelect(raceNum, horseNum) {
            const wrapper = document.createElement("div");
            wrapper.className = "custom-select";
            wrapper.dataset.race = raceNum;
            wrapper.dataset.horse = horseNum;

            const selected = document.createElement("div");
            selected.className = "selected";
            selected.textContent = "";
            selected.dataset.bg = "none";

            const label = document.createElement("span");
            label.className = "horse-label";

            const numSpan = document.createElement("span");
            numSpan.className = "horse-num";
            numSpan.textContent = toCircleNumber(horseNum);

            const nameSpan = document.createElement("span");
            nameSpan.className = "horse-name";
            nameSpan.textContent = "";

            label.appendChild(numSpan);
            label.appendChild(nameSpan);

            selected.addEventListener("click", (e) => {
                if (backgroundMode) {
                    const palette = document.createElement("div");
                    palette.style.position = "absolute";
                    palette.style.zIndex = 9999;
                    palette.style.display = "flex";
                    palette.style.gap = "10px";
                    palette.style.background = "#fff";
                    palette.style.border = "1px solid #999";
                    palette.style.padding = "10px";
                    palette.style.borderRadius = "10px";
                    palette.style.boxShadow = "0 4px 10px rgba(0,0,0,0.2)";

                    const colors = ["#b3d1ff", "#ffc800", "#96c78c", "#e0b3ff", "#afdfe4", "#c8ad9d", "#e761a4"];
                    colors.forEach(c => {
                        const btn = document.createElement("div");
                        btn.style.width = "36px";
                        btn.style.height = "36px";
                        btn.style.backgroundColor = c;
                        btn.style.border = "1px solid #777";
                        btn.style.borderRadius = "6px";
                        btn.style.cursor = "pointer";
                        btn.addEventListener("click", () => {
                            selected.dataset.bg = c;
                            numSpan.style.backgroundColor = c;
                            palette.remove();
                            saveState();
                        });
                        palette.appendChild(btn);
                    });

                    const noneBtn = document.createElement("div");
                    noneBtn.style.width = "36px";
                    noneBtn.style.height = "36px";
                    noneBtn.style.background = "#fff";
                    noneBtn.style.border = "1px solid #777";
                    noneBtn.style.borderRadius = "6px";
                    noneBtn.style.cursor = "pointer";
                    noneBtn.addEventListener("click", () => {
                        selected.dataset.bg = "none";
                        numSpan.style.backgroundColor = "";
                        palette.remove();
                        saveState();
                    });
                    palette.appendChild(noneBtn);

                    document.body.appendChild(palette);
                    const rect = palette.getBoundingClientRect();
                    const pw = rect.width;
                    const ph = rect.height;
                    const vw = window.innerWidth;
                    const vh = window.innerHeight;
                    let left = e.pageX;
                    let top = e.pageY;
                    if (left + pw > vw - 10) left = vw - pw - 10;
                    if (top + ph > vh - 10) top = vh - ph - 10;
                    palette.style.left = left + "px";
                    palette.style.top = top + "px";

                    const closePalette = (ev) => {
                        if (!palette.contains(ev.target)) {
                            palette.remove();
                            document.removeEventListener("click", closePalette);
                        }
                    };
                    setTimeout(() => document.addEventListener("click", closePalette), 0);
                } else {
                    const cur = MARKS.indexOf(selected.textContent);
                    selected.textContent = MARKS[(cur + 1) % MARKS.length];
                    const mark = selected.textContent;
                    selected.style.opacity = "1";
                    applyMarkBackground(wrapper, mark !== "");
                    saveState();
                }
            });

            const oddsLabel = document.createElement("span");
            oddsLabel.className = "odds-label";
            oddsLabel.textContent = ""; const jockeyLabel = document.createElement("span");
            jockeyLabel.className = "jockey-label";
            jockeyLabel.textContent = "";

            const meta = document.createElement("div");
            meta.className = "meta-labels";
            meta.appendChild(oddsLabel);
            meta.appendChild(jockeyLabel);

            wrapper.appendChild(selected);
            wrapper.appendChild(label);
            wrapper.appendChild(meta);
            return wrapper;
        }

        function createTable() {
            const tbody = document.getElementById('raceBody');
            for (let i = 1; i <= HORSE_MAX; i++) {
                const tr = document.createElement('tr');
                for (let r = 1; r <= TOTAL_RACES; r++) {
                    const td = document.createElement('td');
                    td.appendChild(createCustomSelect(r, i));
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            }
        }
        const STORAGE_KEY = 'win5_state_v8';
        const STORAGE_KEY_OLD = 'win5_state_v7';


        let lastState = '';
        function saveState() {
            const state = { races: {}, minFav: document.getElementById('minFav').value, raceInfo: window.raceInfo || ["", "", "", "", ""] };

            for (let r = 1; r <= TOTAL_RACES; r++) {
                state.races[`r${r}`] = {};
                document.querySelectorAll(`.custom-select[data-race="${r}"]`).forEach(sel => {
                    const d = sel.querySelector('.selected');
                    const label = sel.querySelector('.horse-label');
                    const jLabel = sel.querySelector('.jockey-label');
                    let name = null;
                    let jockey = null;

                    if (label) {
                        const numSpan = label.querySelector(".horse-num");
                        const nameSpan = label.querySelector(".horse-name");
                        const numTxt = (numSpan?.textContent || "").trim();
                        const nmTxt = (nameSpan?.textContent || "").trim();

                        if (!numTxt && !nmTxt) {
                            name = null;
                        } else {
                            name = nmTxt;
                        }
                    }

                    if (jLabel) {
                        const jt = (jLabel.textContent || "").trim();
                        if (jt) {
                            jockey = jt;
                        }
                    }

                    const odds = (sel.dataset.odds || "").trim() || null;
                    const ninki = (sel.dataset.ninki || "").trim() || null;

                    state.races[`r${r}`][sel.dataset.horse] = {
                        mark: d.textContent,
                        bg: d.dataset.bg || "none",
                        name: name,
                        jockey: jockey,
                        odds: odds,
                        ninki: ninki
                    };
                });
            }

            const str = JSON.stringify(state);
            if (str !== lastState) {
                localStorage.setItem(STORAGE_KEY, str);
                lastState = str;
            }
        }

        function restoreState() {
            const data = localStorage.getItem(STORAGE_KEY) || localStorage.getItem(STORAGE_KEY_OLD);
            if (!data) return;
            try {
                const state = JSON.parse(data);
                if (state.raceInfo) {
                    window.raceInfo = state.raceInfo;
                    updateRaceHeaders(state.raceInfo);
                }
                if (state.minFav) {
                    document.getElementById('minFav').value = state.minFav;
                }

                for (let r = 1; r <= TOTAL_RACES; r++) {
                    const race = state.races[`r${r}`];
                    if (!race) continue;

                    document.querySelectorAll(`.custom-select[data-race="${r}"]`).forEach(sel => {
                        const val = race[sel.dataset.horse];
                        if (!val) return;

                        const d = sel.querySelector('.selected');
                        const label = sel.querySelector('.horse-label');
                        const jLabel = sel.querySelector('.jockey-label');

                        const oLabel = sel.querySelector('.odds-label');
                        d.textContent = val.mark || "";
                        d.style.opacity = "1";
                        applyMarkBackground(sel, !!val.mark);

                        d.dataset.bg = val.bg || "none";
                        const numSpan = sel.querySelector(".horse-num");
                        if (numSpan) {
                            numSpan.style.backgroundColor = (val.bg && val.bg !== "none") ? val.bg : "";
                        }

                        if (!label) return;

                        const n = val.name;
                        const j = (val.jockey || "").trim();

                        const odds = (val.odds ?? "");
                        const ninki = (val.ninki ?? "");

                        sel.dataset.odds = (odds === null || odds === undefined) ? "" : String(odds);
                        sel.dataset.ninki = (ninki === null || ninki === undefined) ? "" : String(ninki);

                        const p = String(sel.dataset.ninki || "").trim();
                        const o = String(sel.dataset.odds || "").trim();
                        updateOddsLabel(oLabel, p, o);
                        const nNum = label.querySelector(".horse-num");
                        const nName = label.querySelector(".horse-name");
                        const circle = toCircleNumber(Number(sel.dataset.horse));

                        if (n === null) {
                            if (nNum) nNum.textContent = "";
                            if (nName) nName.textContent = "";
                            if (jLabel) jLabel.textContent = "";
                            sel.classList.remove('has-name');
                            sel.style.visibility = 'hidden';

                            sel.dataset.odds = "";
                            sel.dataset.ninki = "";
                            updateOddsLabel(oLabel, "", "");
                            d.textContent = "";
                            d.dataset.bg = "none";
                            if (numSpan) numSpan.style.backgroundColor = "";
                            applyMarkBackground(sel, false);
                        } else if (typeof n === "string" && n.length > 0) {
                            if (nNum) nNum.textContent = circle;
                            if (nName) nName.textContent = " " + n;
                            if (jLabel) jLabel.textContent = j;
                            sel.classList.add('has-name');
                            sel.style.visibility = 'visible';
                        } else {
                            if (nNum) nNum.textContent = circle;
                            if (nName) nName.textContent = "";
                            if (jLabel) jLabel.textContent = j;
                            sel.classList.remove('has-name');
                            sel.style.visibility = 'visible';
                        }
                    });
                }
            } catch (e) { }
        }

        function clearColumn(colNum) {
            document.querySelectorAll(`.custom-select[data-race="${colNum}"]`).forEach(sel => {
                const selected = sel.querySelector(".selected");
                const numSpan = sel.querySelector(".horse-num");

                selected.textContent = "";
                selected.dataset.bg = "none";
                if (numSpan) numSpan.style.backgroundColor = "";

                applyMarkBackground(sel, false);
            });
            saveState();
        }

        function clearAllHorseNames() {
            document.querySelectorAll('.custom-select').forEach(sel => {
                const label = sel.querySelector('.horse-label');
                const jockeyLabel = sel.querySelector('.jockey-label');
                const oLabel = sel.querySelector('.odds-label');
                if (!label) return;

                const horseNum = Number(sel.dataset.horse);
                const circle = toCircleNumber(horseNum);

                const numSpan = label.querySelector(".horse-num");
                const nameSpan = label.querySelector(".horse-name");
                if (numSpan) numSpan.textContent = circle;
                if (nameSpan) nameSpan.textContent = "";

                if (jockeyLabel) {
                    jockeyLabel.textContent = "";
                }
                updateOddsLabel(oLabel, "", "");
                sel.dataset.odds = "";
                sel.dataset.ninki = "";

                sel.classList.remove('has-name');
                sel.style.visibility = 'visible';
            });

            window.raceInfo = ["", "", "", "", ""];
            updateRaceHeaders(window.raceInfo);

            saveState();
        }

        function getRaceData(r) {
            const favs = [], himo = [], colorMap = {};
            document.querySelectorAll(`.custom-select[data-race="${r}"]`).forEach(sel => {
                const v = sel.querySelector('.selected').textContent;
                const bg = sel.querySelector('.selected').dataset.bg;
                const num = Number(sel.dataset.horse);
                colorMap[num] = bg;
                if (v === "◎") favs.push(num);
                if (v === "✓") himo.push(num);
            });
            const all = [...new Set([...favs, ...himo])];
            return { fav: favs, horse: all, colorMap };
        }

        function combinations(arr, k) {
            const res = [];
            (function h(s, c) {
                if (c.length === k) {
                    res.push([...c]);
                    return;
                }
                for (let i = s; i < arr.length; i++) {
                    c.push(arr[i]);
                    h(i + 1, c);
                    c.pop();
                }
            })(0, []);
            return res;
        }

        function attachComboEvents() {
            document.querySelectorAll('#combos .combo-check').forEach(chk => {
                chk.addEventListener('change', () => {
                    const row = chk.closest('.combo-row');
                    if (!row) return;
                    if (chk.checked) {
                        row.classList.add('checked');
                    } else {
                        row.classList.remove('checked');
                    }
                });
            });
        }

        function calc() {
            const t0 = performance.now();

            const races = [], favs = [], colorArray = [];
            for (let i = 1; i <= TOTAL_RACES; i++) {
                const d = getRaceData(i);
                races.push(d.horse);
                favs.push(d.fav);
                const colors = new Array(HORSE_MAX + 1);
                for (let h = 1; h <= HORSE_MAX; h++) colors[h] = d.colorMap[h] || "none";
                colorArray.push(colors);
            }

            const favMaskList = favs.map(a => a.map(x => 1 << (x - 1)));
            const nonFavMaskList = races.map((a, idx) => {
                const favSet = new Set(favs[idx]);
                return a.filter(x => !favSet.has(x)).map(x => 1 << (x - 1));
            });

            const colorIdTable = Array.from(
                { length: TOTAL_RACES },
                () => new Int16Array(HORSE_MAX).fill(-1)
            );
            const colorIdMap = new Map();
            let nextColorId = 0;
            for (let i = 0; i < TOTAL_RACES; i++) {
                const usedHorses = races[i];
                for (let idx = 0; idx < usedHorses.length; idx++) {
                    const h = usedHorses[idx];
                    const c = colorArray[i][h];
                    if (c && c !== "none") {
                        let id = colorIdMap.get(c);
                        if (id === undefined) {
                            id = nextColorId++;
                            colorIdMap.set(c, id);
                        }
                        colorIdTable[i][h - 1] = id;
                    }
                }
            }

            const masksCache = {};
            function getMasks(k) {
                if (!masksCache[k]) masksCache[k] = combinations([...Array(TOTAL_RACES).keys()], k);
                return masksCache[k];
            }

            function countCombosDFS(candidates) {
                const n = candidates.length;

                const order = Array.from({ length: n }, (_, i) => i)
                    .sort((a, b) => candidates[a].length - candidates[b].length);

                const revOrder = new Int8Array(n);
                for (let i = 0; i < n; i++) revOrder[order[i]] = i;

                const candColorIds = new Array(n);
                for (let r = 0; r < n; r++) {
                    const arr = candidates[r];
                    const ids = new Int16Array(arr.length);
                    for (let i = 0; i < arr.length; i++) {
                        const bit = arr[i];
                        const idx = Math.log2(bit) | 0;
                        ids[i] = colorIdTable[r][idx];
                    }
                    candColorIds[r] = ids;
                }

                let count = 0;
                const blocks = [];
                const path = new Int32Array(n);

                const dfs = (depth, usedColorMask) => {
                    if (depth === n) {
                        count++;
                        const combo = new Array(n);
                        for (let i = 0; i < n; i++) combo[i] = path[revOrder[i]];
                        blocks.push(combo);
                        return;
                    }

                    const raceIdx = order[depth];
                    const arr = candidates[raceIdx];
                    const colorIds = candColorIds[raceIdx];

                    for (let k = 0; k < arr.length; k++) {
                        const m = arr[k];
                        const colorId = colorIds[k];

                        if (colorId >= 0 && (usedColorMask & (1 << colorId))) continue;

                        path[depth] = m;
                        const nextMask = (colorId >= 0) ? (usedColorMask | (1 << colorId)) : usedColorMask;
                        dfs(depth + 1, nextMask);
                    }
                };

                dfs(0, 0);
                return { count, blocks };
            }

            const minFav = Number(document.getElementById('minFav').value);
            let total = 0;
            const comboList = [];

            const k = minFav;
            const masks = getMasks(k);
            let count = 0;
            let blocks = [];

            for (let m = 0; m < masks.length; m++) {
                const maskArr = masks[m];
                const maskSet = new Set(maskArr);
                const candidates = new Array(TOTAL_RACES);
                let valid = true;

                for (let i = 0; i < TOTAL_RACES; i++) {
                    candidates[i] = maskSet.has(i) ? favMaskList[i] : nonFavMaskList[i];
                    if (candidates[i].length === 0) { valid = false; break; }
                }
                if (!valid) continue;

                const res = countCombosDFS(candidates);
                count += res.count;

                for (let i = 0; i < res.blocks.length; i++) {
                    blocks.push(res.blocks[i]);
                }
            }

            const displayBlocks = fullyMergeBlocksStableBit(blocks);
            comboList.push('<div class="combo-grid">');
            for (const b of displayBlocks) comboList.push(blockToLineBit(b));
            comboList.push('</div>');

            total = count;

            const t1 = performance.now();
            const elapsedMs = t1 - t0;
            console.log(`計算速度: ${elapsedMs.toFixed()} ms`);

            document.getElementById('result').innerHTML =
                `買い目：<span style="color:#0078d4;">${total.toLocaleString()}</span> 通り`;
            const combosEl = document.getElementById('combos');
            const combosHtml = comboList.join('');
            if (!combosHtml.trim()) {
                combosEl.replaceChildren();
            } else {
                const container = document.createElement('div');
                container.innerHTML = combosHtml;
                combosEl.replaceChildren(container);
                attachComboEvents();
            }
            saveState();
        }

        function fullyMergeBlocksStableBit(blocks) {
            const n = TOTAL_RACES | 0;
            if (blocks.length <= 1) return blocks;

            let changed = true;
            while (changed) {
                changed = false;

                for (let d = 0; d < n; d++) {
                    const len = blocks.length;
                    if (len <= 1) break;

                    const map = new Map();
                    for (let i = 0; i < len; i++) {
                        const b = blocks[i];
                        let key = "";
                        for (let k = 0; k < n; k++) {
                            if (k === d) continue;
                            key += b[k] + ",";
                        }
                        let arr = map.get(key);
                        if (!arr) {
                            arr = [];
                            map.set(key, arr);
                        }
                        arr.push(i);
                    }

                    const used = new Uint8Array(len);
                    const next = [];

                    for (let i = 0; i < len; i++) {
                        if (used[i]) continue;

                        const baseRow = blocks[i];
                        let key = "";
                        for (let k = 0; k < n; k++) {
                            if (k === d) continue;
                            key += baseRow[k] + ",";
                        }
                        const group = map.get(key);

                        if (!group || group.length === 1) {
                            next.push(baseRow);
                            used[i] = 1;
                            continue;
                        }

                        let mergedRow = baseRow.slice();
                        used[i] = 1;

                        for (let gi = 0; gi < group.length; gi++) {
                            const j = group[gi];
                            if (j === i || used[j]) continue;

                            const row = blocks[j];
                            if ((mergedRow[d] & row[d]) === 0) {
                                mergedRow[d] |= row[d];
                                used[j] = 1;
                                changed = true;
                            }
                        }

                        next.push(mergedRow);
                    }

                    blocks = next;
                }
            }
            return blocks;
        }

        function blockToLineBit(block) {
            const parts = block.map(mask => {
                const nums = [];
                for (let i = 0; i < HORSE_MAX; i++) {
                    if (mask & (1 << i)) nums.push(toCircleNumber(i + 1));
                }
                return nums.join('');
            });
            const cells = parts.map(p => `<span class="combo-cell">${p}</span>`).join('');
            return (
                '<div class="combo-row">' +
                '<label class="combo-check-wrap">' +
                '<input type="checkbox" class="combo-check">' +
                '<span class="combo-check-visual">✓</span>' +
                '</label>' +
                cells +
                '</div>'
            );
        }

        const WIN5_API = "https://win5-proxy.cooopew.workers.dev/";

        function applyWin5Data(json) {
            window.raceInfo = json.raceInfo || [];
            updateRaceHeaders(window.raceInfo);

            const races = json.races || [];

            for (let r = 0; r < TOTAL_RACES; r++) {
                const horses = (races[r] && races[r].horses) ? races[r].horses : [];
                const jockeys = (races[r] && races[r].jockeys) ? races[r].jockeys : [];
                const oddsArr = (races[r] && races[r].odds) ? races[r].odds : [];
                const ninkiArr = (races[r] && races[r].ninki) ? races[r].ninki : [];

                for (let i = 1; i <= HORSE_MAX; i++) {
                    const raceNum = r + 1;
                    const horseNum = i;
                    const name = horses[i - 1] || "";
                    const jockey = jockeys[i - 1] || "";

                    const sel = document.querySelector(
                        `.custom-select[data-race="${raceNum}"][data-horse="${horseNum}"]`
                    );
                    if (!sel) continue;

                    const label = sel.querySelector(".horse-label");
                    const selected = sel.querySelector(".selected");
                    const oddsLabel = sel.querySelector(".odds-label");
                    const jockeyLabel = sel.querySelector(".jockey-label");
                    if (!label || !selected || !oddsLabel || !jockeyLabel) continue;

                    const circle = toCircleNumber(horseNum);
                    const numSpan = label.querySelector(".horse-num");
                    const nameSpan = label.querySelector(".horse-name");

                    if (name) {
                        if (numSpan) numSpan.textContent = circle;
                        if (nameSpan) nameSpan.textContent = " " + name;
                        jockeyLabel.textContent = jockey || "";
                        const odds = oddsArr[i - 1];
                        const ninki = ninkiArr[i - 1];

                        sel.dataset.odds = (odds === undefined || odds === null) ? "" : String(odds);
                        sel.dataset.ninki = (ninki === undefined || ninki === null) ? "" : String(ninki);

                        const p = String(sel.dataset.ninki || "").trim();
                        const o = String(sel.dataset.odds || "").trim();
                        updateOddsLabel(oddsLabel, p, o);
                        sel.classList.add("has-name");
                        sel.style.visibility = "visible";
                    } else {
                        if (numSpan) numSpan.textContent = "";
                        if (nameSpan) nameSpan.textContent = "";
                        jockeyLabel.textContent = "";
                        updateOddsLabel(oddsLabel, "", "");
                        sel.dataset.odds = "";
                        sel.dataset.ninki = "";
                        sel.classList.remove("has-name");
                        sel.style.visibility = "hidden";

                        selected.textContent = "";
                        selected.dataset.bg = "none";
                        const ns = sel.querySelector(".horse-num");
                        if (ns) ns.style.backgroundColor = "";
                        applyMarkBackground(sel, false);
                    }
                }
            }

            saveState();
        }

        function updateRaceHeaders(raceInfo) {
            const thRow = document.querySelector("#raceTable thead tr");
            thRow.innerHTML = "";

            for (let i = 0; i < 5; i++) {
                const th = document.createElement("th");
                const label = `WIN${i + 1}` + (raceInfo[i] ? ` ${raceInfo[i]}` : "");
                th.textContent = label;
                thRow.appendChild(th);
            }
        }

        async function loadWin5Data() {
            const idx = document.getElementById("win5TabSelect").value;

            const u = new URL(WIN5_API);
            u.searchParams.set("tab", idx);
            u.searchParams.set("_", String(Date.now()));

            const res = await fetch(u.toString(), { cache: "no-store" });
            const json = await res.json();

            if (!json.ok) return;

            applyWin5Data(json);
        }

        async function loadWin5Tabs() {
            const u = new URL(WIN5_API);
            u.searchParams.set("_", String(Date.now()));

            const res = await fetch(u.toString(), { cache: "no-store" });
            const json = await res.json();

            if (!json.ok) return;

            const tabs = json.tabs || [];
            const current = json.activeTab ?? 0;

            const select = document.getElementById("win5TabSelect");
            if (!select) return;

            select.innerHTML = "";

            tabs.forEach((t, i) => {
                const op = document.createElement("option");
                op.value = i;
                op.textContent = t.label;
                if (i === current) op.selected = true;
                select.appendChild(op);
            });
        }

        function applyMarkBackground(sel, hasMark) {
            const td = sel.parentElement;
            if (td) td.style.backgroundColor = hasMark ? "#fff0f0" : "";

            const box = sel.querySelector(".selected");
            if (!box) return;

            if (hasMark) {
                box.classList.add("is-marked");
            } else {
                box.classList.remove("is-marked");
            }
        }

        function openShare() {
            const modal = document.getElementById("shareModal");
            const ta = document.getElementById("shareText");
            if (!modal || !ta) return;

            const payload = buildSharePayload();
            const token = encodeSharePayload(payload);

            const base = location.href.split("#")[0];
            const url = `${base}#share=${token}`;

            ta.value = url;

            modal.style.display = "flex";
            document.body.style.overflow = "hidden";
            modal.onclick = () => closeShare();
            if (!window.matchMedia("(hover: none) and (pointer: coarse)").matches) {
                ta.focus();
                ta.select();
            }
        }

        function closeShare() {
            const modal = document.getElementById("shareModal");
            if (modal) modal.style.display = "none";
            document.body.style.overflow = "";
        }

        async function copyShareText() {
            const ta = document.getElementById("shareText");
            if (!ta) return;
            const txt = ta.value || "";
            if (!txt) return;

            try {
                await navigator.clipboard.writeText(txt);
            } catch (e) {
                ta.focus();
                ta.select();
                document.execCommand("copy");
            }
        }

        function importShareText() {
            const ta = document.getElementById("shareText");
            if (!ta) return;
            const raw = (ta.value || "").trim();
            if (!raw) return;

            const token = extractShareToken(raw);
            if (!token) return;

            try {
                const payload = decodeSharePayload(token);
                applySharePayload(payload);
                closeShare();
            } catch (e) {
                console.error("share import failed", e);
            }
        }

        function extractShareToken(txt) {
            const t = (txt || "").trim();
            const m = t.match(/[?#&]share=([A-Za-z0-9\-_]+)/);
            if (m) return m[1];
            if (/^[A-Za-z0-9\-_]{20,}$/.test(t)) return t;
            return null;
        }

        function buildSharePayload() {
            const items = [];
            document.querySelectorAll(".custom-select").forEach(sel => {
                const r = Number(sel.dataset.race);
                const h = Number(sel.dataset.horse);
                const box = sel.querySelector(".selected");
                const mark = (box?.textContent || "").trim();
                const bg = (box?.dataset.bg || "none").trim();

                if (mark || (bg && bg !== "none")) {
                    items.push([r, h, mark, bg]);
                }
            });
            return { v: 1, items };
        }

        function applySharePayload(payload) {
            if (!payload || payload.v !== 1 || !Array.isArray(payload.items)) return;
            document.querySelectorAll(".custom-select").forEach(sel => {
                const box = sel.querySelector(".selected");
                const numSpan = sel.querySelector(".horse-num");
                if (!box) return;

                box.textContent = "";
                box.dataset.bg = "none";
                if (numSpan) numSpan.style.backgroundColor = "";

                applyMarkBackground(sel, false);
            });

            for (const it of payload.items) {
                if (!Array.isArray(it) || it.length < 4) continue;
                const [r, h, mark, bg] = it;

                const sel = document.querySelector(`.custom-select[data-race="${r}"][data-horse="${h}"]`);
                if (!sel) continue;

                const box = sel.querySelector(".selected");
                const numSpan = sel.querySelector(".horse-num");
                if (!box) continue;

                const m = (mark || "").toString();
                const b = (bg || "none").toString();

                box.textContent = m;
                applyMarkBackground(sel, !!m);

                box.dataset.bg = b;
                if (numSpan) numSpan.style.backgroundColor = (b && b !== "none") ? b : "";
            }

            saveState();
        }

        function encodeSharePayload(obj) {
            const json = JSON.stringify(obj);
            const b64 = btoa(unescape(encodeURIComponent(json)));
            return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
        }

        function decodeSharePayload(token) {
            const t = token.replace(/-/g, "+").replace(/_/g, "/");
            const pad = t.length % 4 ? "=".repeat(4 - (t.length % 4)) : "";
            const json = decodeURIComponent(escape(atob(t + pad)));
            return JSON.parse(json);
        }

        function applyShareFromURL() {
            const hash = location.hash || "";
            const m = hash.match(/share=([A-Za-z0-9\-_]+)/);
            if (!m) return;

            try {
                const payload = decodeSharePayload(m[1]);
                applySharePayload(payload);
                const base = location.href.split("#")[0];
                history.replaceState(null, "", base);
            } catch (e) {
                console.error("share parse failed", e);
            }
        }

        createTable();
        restoreState();
        applyShareFromURL();
        loadWin5Tabs();

        function isMobileLayout() {
            return window.matchMedia("(max-width: 640px)").matches;
        }

        function applyRaceFocus(race) {
            if (!isMobileLayout()) {
                document.body.dataset.focusRace = "all";
                const bar = document.getElementById("raceFocusBar");
                if (bar) bar.querySelectorAll("button").forEach(b => b.classList.remove("on"));
                return;
            }

            document.body.dataset.focusRace = race;
            const bar = document.getElementById("raceFocusBar");
            if (!bar) return;
            bar.querySelectorAll("button").forEach(b => {
                b.classList.toggle("on", b.dataset.race === race);
            });
        }

        function setupMobileRaceFocusBar() {
            const bar = document.getElementById("raceFocusBar");
            if (!bar) return;

            bar.innerHTML = "";
            const labels = [
                { race: "all", text: "全表示" },
                { race: "1", text: "WIN1" },
                { race: "2", text: "WIN2" },
                { race: "3", text: "WIN3" },
                { race: "4", text: "WIN4" },
                { race: "5", text: "WIN5" },
            ];

            for (const item of labels) {
                const btn = document.createElement("button");
                btn.type = "button";
                btn.dataset.race = item.race;
                btn.textContent = item.text;
                btn.addEventListener("click", () => applyRaceFocus(item.race));
                bar.appendChild(btn);
            }

            applyRaceFocus("all");
        }

        window.addEventListener("resize", () => {
            applyRaceFocus(document.body.dataset.focusRace || "all");
        });

        setupMobileRaceFocusBar();
    </script>

</body>

</html>